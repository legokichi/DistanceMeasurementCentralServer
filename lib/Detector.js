// Generated by CoffeeScript 1.10.0
(function() {
  var MULTIPASS_DISTANCE, OSC, SOUND_OF_SPEED, Signal, SignalViewer;

  SignalViewer = window["SignalViewer"];

  Signal = window["Signal"];

  OSC = window["duxca"]["lib"]["OSC"];

  MULTIPASS_DISTANCE = 9;

  SOUND_OF_SPEED = 340;

  this.Detector = (function() {
    function Detector(actx) {
      this.actx = actx;
      this.osc = new OSC(this.actx);
      this.abuf = null;
      this.matchedA = null;
      this.matchedB = null;
      this.pulseType = null;
    }

    Detector.prototype.init = function(data, next) {
      var pulseType;
      pulseType = data.pulseType;
      this.pulseType = pulseType;
      switch (this.pulseType) {
        case "barker":
          return this.init_barker(data, next);
        case "chirp":
          return this.init_chirp(data, next);
        case "barkerCodedChirp":
          return this.init_barkerCodedChirp(data, next);
        case "mseq":
          return this.init_mseq(data, next);
        default:
          throw new Error("uknown pulse type " + pulseType);
      }
    };

    Detector.prototype.init_barker = function(arg, next) {
      var barker, carrierFreq;
      carrierFreq = arg.carrierFreq;
      barker = Signal.createBarkerCode(13);
      this.matchedA = Signal.BPSK(barker, carrierFreq, this.actx.sampleRate, 0);
      this.abuf = this.osc.createAudioBufferFromArrayBuffer(this.matchedA, this.actx.sampleRate);
      return next();
    };

    Detector.prototype.init_chirp = function(arg, next) {
      var chirp, length;
      length = arg.length;
      chirp = Signal.createChirpSignal(length);
      this.matchedA = chirp;
      this.abuf = this.osc.createAudioBufferFromArrayBuffer(this.matchedA, this.actx.sampleRate);
      return next();
    };

    Detector.prototype.init_barkerCodedChirp = function(arg, next) {
      var bcc, length;
      length = arg.length;
      bcc = Signal.createBarkerCodedChirp(13, length);
      this.matchedA = bcc;
      this.abuf = this.osc.createAudioBufferFromArrayBuffer(this.matchedA, this.actx.sampleRate);
      return next();
    };

    Detector.prototype.init_mseq = function(arg, next) {
      var carrierFreq, length, mseqA, mseqB, seedA, seedB, signal;
      length = arg.length, seedA = arg.seedA, seedB = arg.seedB, carrierFreq = arg.carrierFreq;
      mseqA = Signal.mseqGen(length, seedA);
      mseqB = Signal.mseqGen(length, seedB);
      this.matchedA = Signal.BPSK(mseqA, carrierFreq, this.actx.sampleRate, 0);
      this.matchedB = Signal.BPSK(mseqB, carrierFreq, this.actx.sampleRate, 0);
      signal = new Float32Array(this.matchedA.length * 2 + this.matchedB.length);
      signal.set(this.matchedA, 0);
      signal.set(this.matchedB, this.matchedA.length * 2);
      this.abuf = this.osc.createAudioBufferFromArrayBuffer(signal, this.actx.sampleRate);
      return next();
    };

    Detector.prototype.beep = function(next) {
      var anode, recur, startTime;
      startTime = this.actx.currentTime;
      anode = this.osc.createAudioNodeFromAudioBuffer(this.abuf);
      anode.connect(this.actx.destination);
      anode.start(startTime);
      return (recur = (function(_this) {
        return function() {
          if ((startTime + _this.abuf.duration) < _this.actx.currentTime) {
            return setTimeout(next, 100);
          } else {
            return setTimeout(recur, 100);
          }
        };
      })(this))();
    };

    Detector.prototype.calc = function(f32arr, startStops, opt) {
      var sampleRate, slideWidth, windowSize;
      if (opt == null) {
        opt = {};
      }
      sampleRate = opt.sampleRate;
      if (sampleRate == null) {
        sampleRate = this.actx.sampleRate;
      }
      windowSize = Math.pow(2, 8);
      slideWidth = Math.pow(2, 4);
      switch (this.pulseType) {
        case "barker":
          return startStops.map(this.calc_barker(f32arr, sampleRate));
        case "chirp":
          return startStops.map(this.calc_chirp(f32arr, sampleRate));
        case "barkerCodedChirp":
          return startStops.map(this.calc_barkerCodedChirp(f32arr, sampleRate));
        case "mseq":
          return startStops.map(this.calc_mseq(f32arr, sampleRate));
        default:
          throw new Error("uknown pulse type " + pulseType);
      }
    };

    Detector.prototype.calc_barker = function(rawdata, sampleRate) {
      return (function(_this) {
        return function(arg) {
          var correlA, filename_head, id, idxA, images, marker, maxA, max_offset, max_val, pulseTime, range, ref, section, startPtr, stopPtr, zoomA;
          id = arg.id, startPtr = arg.startPtr, stopPtr = arg.stopPtr;
          images = {};
          filename_head = "-TO-" + id + "_";
          section = rawdata.subarray(startPtr, stopPtr);
          correlA = Signal.fft_smart_overwrap_correlation(section, _this.matchedA);
          images[filename_head + "section"] = section;
          images[filename_head + "correlA"] = correlA;
          ref = Signal.Statictics.findMax(correlA), maxA = ref[0], idxA = ref[1];
          range = (MULTIPASS_DISTANCE / SOUND_OF_SPEED * sampleRate) | 0;
          marker = new Uint8Array(correlA.length);
          marker[idxA - range] = 255;
          marker[idxA] = 255;
          marker[idxA + range] = 255;
          images[filename_head + "marker"] = marker;
          zoomA = correlA.subarray(idxA - range, idxA + range);
          images[filename_head + "zoomA"] = zoomA;
          max_offset = idxA;
          pulseTime = (startPtr + max_offset) / sampleRate;
          max_val = maxA;
          return {
            images: images,
            results: {
              id: id,
              max_offset: max_offset,
              pulseTime: pulseTime,
              max_val: max_val
            }
          };
        };
      })(this);
    };

    Detector.prototype.calc_chirp = function(rawdata, sampleRate) {
      return (function(_this) {
        return function(arg) {
          var id, startPtr, stopPtr;
          id = arg.id, startPtr = arg.startPtr, stopPtr = arg.stopPtr;
          return _this.calc_barker(rawdata, sampleRate)({
            id: id,
            startPtr: startPtr,
            stopPtr: stopPtr
          });
        };
      })(this);
    };

    Detector.prototype.calc_barkerCodedChirp = function(rawdata, sampleRate) {
      return (function(_this) {
        return function(arg) {
          var id, startPtr, stopPtr;
          id = arg.id, startPtr = arg.startPtr, stopPtr = arg.stopPtr;
          return _this.calc_barker(rawdata, sampleRate)({
            id: id,
            startPtr: startPtr,
            stopPtr: stopPtr
          });
        };
      })(this);
    };

    Detector.prototype.calc_mseq = function(rawdata, sampleRate) {
      return (function(_this) {
        return function(arg) {
          var _, _idx, correl, correlA, correlB, filename_head, i, id, idx, idxA, idxB, images, logs, lowpass, marker, marker2, max, maxA, maxB, max_offset, max_val, pulseTime, range, ref, ref1, ref2, ref3, ref4, relA, relB, scoreA, scoreB, section, slidewidth, startPtr, stdscoreA, stdscoreB, stopPtr, val, windowsize, zoom, zoomA, zoomB;
          id = arg.id, startPtr = arg.startPtr, stopPtr = arg.stopPtr;
          images = {};
          filename_head = "-TO-" + id + "_";
          section = rawdata.subarray(startPtr, stopPtr);
          correlA = Signal.fft_smart_overwrap_correlation(section, _this.matchedA);
          correlB = Signal.fft_smart_overwrap_correlation(section, _this.matchedB);
          images[filename_head + "section"] = section;
          images[filename_head + "correlA"] = correlA;
          images[filename_head + "correlB"] = correlB;
          ref = Signal.Statictics.findMax(correlA), _ = ref[0], idxA = ref[1];
          ref1 = Signal.Statictics.findMax(correlB), _ = ref1[0], idxB = ref1[1];
          relB = idxA + _this.matchedA.length * 2;
          if (relB < 0) {
            relB = 0;
          }
          relA = idxB - _this.matchedA.length * 2;
          if (relA < 0) {
            relA = 0;
          }
          stdscoreA = (function() {
            var ave, vari;
            ave = Signal.Statictics.average(correlA);
            vari = Signal.Statictics.variance(correlA);
            if (vari === 0) {
              vari = 0.000001;
            }
            return function(x) {
              return 10 * (x - ave) / vari + 50;
            };
          })();
          stdscoreB = (function() {
            var ave, vari;
            ave = Signal.Statictics.average(correlB);
            vari = Signal.Statictics.variance(correlB);
            if (vari === 0) {
              vari = 0.000001;
            }
            return function(x) {
              return 10 * (x - ave) / vari + 50;
            };
          })();
          scoreB = stdscoreB(correlB[idxB]) + stdscoreA(correlA[relA]);
          scoreA = stdscoreA(correlA[idxA]) + stdscoreB(correlB[relB]);
          range = (MULTIPASS_DISTANCE / SOUND_OF_SPEED * sampleRate) | 0;
          if (relA > 0 && scoreB > scoreA) {
            ref2 = Signal.Statictics.findMax(correlA.subarray(relA - range, relA + range)), _ = ref2[0], idx = ref2[1];
            idxA = relA - range + idx;
          } else {
            ref3 = Signal.Statictics.findMax(correlB.subarray(relB - range, relB + range)), _ = ref3[0], idx = ref3[1];
            idxB = relB - range + idx;
          }
          maxA = correlA[idxA];
          maxB = correlB[idxB];
          marker = new Uint8Array(correlA.length);
          marker[idxA - range] = 255;
          marker[idxA] = 255;
          marker[idxA + range] = 255;
          marker[idxB - range] = 255;
          marker[idxB] = 255;
          marker[idxB + range] = 255;
          images[filename_head + "marker"] = marker;
          zoomA = correlA.subarray(idxA - range, idxA + range);
          zoomB = correlB.subarray(idxB - range, idxB + range);
          images[filename_head + "zoomA"] = zoomA;
          images[filename_head + "zoomB"] = zoomB;
          correl = Signal.fft_smart_overwrap_correlation(zoomA, zoomB);
          images[filename_head + "correl"] = correl;
          zoom = zoomA.map(function(_, i) {
            return zoomA[i] * zoomB[i];
          });
          logs = new Float32Array(zoom.length);
          windowsize = (0.6 / SOUND_OF_SPEED * sampleRate) | 0;
          slidewidth = 1;
          i = 0;
          while (zoomA.length > i + windowsize) {
            val = zoom.subarray(i, i + windowsize).reduce((function(sum, v, i) {
              return sum + v;
            }), 0);
            logs[i] = val;
            i += slidewidth;
          }
          images[filename_head + "logs"] = logs;
          lowpass = Signal.lowpass(logs, sampleRate, 800, 1);
          images[filename_head + "lowpass"] = lowpass;
          ref4 = Signal.Statictics.findMax(lowpass), max = ref4[0], _idx = ref4[1];
          i = 1;
          while (i < _idx && lowpass[i] < max / 5) {
            i++;
          }
          while (i < _idx && lowpass[i] > lowpass[i - 1]) {
            i++;
          }
          idx = i;
          marker2 = new Uint8Array(logs.length);
          marker2[idx] = 255;
          images[filename_head + "marker2"] = marker2;
          max_offset = idx + (idxA - range);
          pulseTime = (startPtr + max_offset) / sampleRate;
          max_val = (maxA + maxB) / 2;
          return {
            images: images,
            results: {
              id: id,
              max_offset: max_offset,
              pulseTime: pulseTime,
              max_val: max_val
            }
          };
        };
      })(this);
    };

    return Detector;

  })();

}).call(this);
