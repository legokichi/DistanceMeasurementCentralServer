// Generated by CoffeeScript 1.10.0
(function() {
  var Detector, JSZip, RecordBuffer, Wave, __UPLOADER_POST_URL__, __VIEW_SIZE__, blobToBuffer, getSignalImage, post;

  RecordBuffer = window["duxca"]["lib"]["RecordBuffer"];

  Wave = window["duxca"]["lib"]["Wave"];

  Detector = window["Detector"];

  JSZip = window["JSZip"];

  __UPLOADER_POST_URL__ = "/upload";

  __VIEW_SIZE__ = Math.pow(2, 12);

  this.Recorder = (function() {
    function Recorder(actx, color) {
      this.actx = actx;
      this.alias = color;
      this.isRecording = false;
      this.nextTick = null;
      this.pulseStartTime = {};
      this.pulseStopTime = {};
      this.processor = this.actx.createScriptProcessor(Math.pow(2, 14), 1, 1);
      this.processor.connect(this.actx.destination);
      this.processor.addEventListener("audioprocess", this.audioprocess.bind(this));
      this.gain = this.actx.createGain();
      this.gain.connect(this.actx.destination);
      this.recbuf = new RecordBuffer(this.actx.sampleRate, this.processor.bufferSize, this.processor.channelCount);
      this.detector = new Detector(this.actx);
    }

    Recorder.prototype.audioprocess = function(ev) {
      var fn;
      if (this.isRecording) {
        this.recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], this.actx.currentTime);
      }
      if (this.nextTick instanceof Function) {
        fn = this.nextTick;
        this.nextTick = null;
        return fn();
      }
    };

    Recorder.prototype.prepareRec = function(next) {
      var left, right;
      left = function(err) {
        throw err;
      };
      right = (function(_this) {
        return function(stream) {
          var source;
          source = _this.actx.createMediaStreamSource(stream);
          source.connect(_this.processor);
          return next();
        };
      })(this);
      return navigator.getUserMedia({
        video: false,
        audio: true
      }, right, left);
    };

    Recorder.prototype.ready = function(data) {
      return (function(_this) {
        return function(next) {
          _this.recbuf.clear();
          return _this.detector.init(data, next);
        };
      })(this);
    };

    Recorder.prototype.startRec = function(next) {
      this.isRecording = true;
      return next();
    };

    Recorder.prototype.startPulse = function(id) {
      return (function(_this) {
        return function(next) {
          _this.pulseStartTime[id] = _this.actx.currentTime;
          return next();
        };
      })(this);
    };

    Recorder.prototype.beepPulse = function(next) {
      return this.detector.beep(next);
    };

    Recorder.prototype.stopPulse = function(id) {
      return (function(_this) {
        return function(next) {
          return _this.nextTick = function() {
            _this.pulseStopTime[id] = _this.actx.currentTime;
            return next();
          };
        };
      })(this);
    };

    Recorder.prototype.stopRec = function(next) {
      this.isRecording = false;
      return next();
    };

    Recorder.prototype.collect = function(data) {
      return (function(_this) {
        return function(next) {
          var alias, experimentID, f32arr, id, int16arr, pulseType, recStartTime, recStopTime, sampleRate, startStops, timeStamp;
          experimentID = data.experimentID, pulseType = data.pulseType, timeStamp = data.timeStamp;
          recStartTime = _this.recbuf.sampleTimes[0] - (_this.recbuf.bufferSize / _this.recbuf.sampleRate);
          recStopTime = _this.recbuf.sampleTimes[_this.recbuf.sampleTimes.length - 1];
          startStops = Object.keys(_this.pulseStartTime).map(function(id) {
            var startPtr, stopPtr;
            startPtr = (_this.pulseStartTime[id] - recStartTime) * _this.recbuf.sampleRate | 0;
            stopPtr = (_this.pulseStopTime[id] - recStartTime) * _this.recbuf.sampleRate | 0;
            return {
              id: id,
              startPtr: startPtr,
              stopPtr: stopPtr
            };
          });
          id = socket.id;
          alias = _this.alias;
          sampleRate = _this.actx.sampleRate;
          f32arr = _this.recbuf.merge();
          int16arr = _this.recbuf.toPCM();
          _this.recbuf.clear();
          return _this.detector.calc(f32arr, startStops).then(function(results) {
            var imageses, pulseInfos, resObj;
            pulseInfos = results.map(function(arg) {
              var pulseInfo;
              pulseInfo = arg.pulseInfo;
              return pulseInfo;
            });
            resObj = {
              experimentID: experimentID,
              pulseType: pulseType,
              timeStamp: timeStamp,
              id: id,
              alias: alias,
              sampleRate: sampleRate,
              recStartTime: recStartTime,
              recStopTime: recStopTime,
              startStops: startStops,
              pulseInfos: pulseInfos
            };
            imageses = results.map(function(arg) {
              var images;
              images = arg.images;
              return images;
            });
            return _this.upload(resObj, f32arr, int16arr, imageses).then(function() {
              return next(resObj);
            });
          });
        };
      })(this);
    };

    Recorder.prototype.upload = function(resObj, f32arr, int16arr, imageses) {
      var alias, dat, experimentID, id, json, jszip, prefix, pulseInfos, pulseType, recStartTime, recStopTime, sampleRate, startStops, timeStamp, wave;
      experimentID = resObj.experimentID, pulseType = resObj.pulseType, timeStamp = resObj.timeStamp, id = resObj.id, alias = resObj.alias, sampleRate = resObj.sampleRate, recStartTime = resObj.recStartTime, recStopTime = resObj.recStopTime, startStops = resObj.startStops, pulseInfos = resObj.pulseInfos;
      json = JSON.stringify(resObj, null, "  ");
      dat = f32arr.buffer;
      wave = new Wave(1, sampleRate, int16arr).view.buffer;
      prefix = experimentID + "_" + pulseType + "_" + timeStamp + "_collect_" + alias + "_" + id;
      jszip = new JSZip();
      jszip.file(prefix + ".json", json);
      jszip.file(prefix + ".wav", wave);
      jszip.file(prefix + ".dat", dat);
      return Promise.all(imageses.map(function(images) {
        return Promise.all(Object.keys(images).map(function(filename) {
          return getSignalImage(images[filename]).then(function(blob) {
            return blobToBuffer(blob).then(function(jpg) {
              return jszip.file(prefix + "_" + filename + ".jpg", jpg);
            });
          });
        }));
      })).then(function() {
        var zip;
        zip = jszip.generate({
          type: "blob",
          compressionOptions: 9
        });
        return post(__UPLOADER_POST_URL__, {
          filename: prefix + ".zip",
          file: zip
        });
      })["catch"](function(err) {
        return console.error(err);
      });
    };

    Recorder.prototype.distribute = function(data) {
      return (function(_this) {
        return function(next) {
          var alias, datas, experimentID, id, json, prefix, pulseType, results, timeStamp;
          experimentID = data.experimentID, pulseType = data.pulseType, timeStamp = data.timeStamp, datas = data.datas;
          id = socket.id;
          alias = _this.alias;
          prefix = experimentID + "_" + pulseType + "_" + timeStamp + "_distribute_" + alias + "_" + id;
          results = _this.detector.distribute(datas);
          json = new Blob([JSON.stringify(results, null, "  ")]);
          Promise.resolve().then(function() {
            return post(__UPLOADER_POST_URL__, {
              filename: prefix + ".json",
              file: json
            });
          });
          return next();
        };
      })(this);
    };

    Recorder.prototype.play = function(data) {
      return console.log("play", data);
    };

    Recorder.prototype.volume = function(data) {
      return console.log("volume", data);
    };

    return Recorder;

  })();

  post = function(url, param) {
    var formData;
    formData = new FormData();
    Object.keys(param).forEach(function(key) {
      return formData.append(key, param[key]);
    });
    return $.ajax({
      type: 'POST',
      url: url,
      data: formData,
      contentType: false,
      processData: false
    }).promise();
  };

  getSignalImage = function(arr) {
    return new Promise(function(resolve) {
      var render, width;
      width = __VIEW_SIZE__ < arr.length ? __VIEW_SIZE__ : arr.length;
      render = new SignalViewer(width, 64);
      render.draw(arr);
      return render.cnv.toBlob(resolve, "image/jpeg", 0.5);
    });
  };

  blobToBuffer = function(blob) {
    return new Promise(function(resolve, reject) {
      var reader;
      reader = new FileReader();
      reader.onerror = reject;
      reader.onload = function() {
        var buffer;
        buffer = this.result;
        return resolve(buffer);
      };
      return reader.readAsArrayBuffer(blob);
    });
  };

}).call(this);
