// Generated by CoffeeScript 1.10.0
var Signal;

Signal = window["Signal"];

this.SignalViewer = (function() {
  function SignalViewer(width, height) {
    this.cnv = document.createElement("canvas");
    this.cnv.width = width;
    this.cnv.height = height;
    this.ctx = this.cnv.getContext("2d");
    this.offsetX = 0;
    this.offsetY = this.cnv.height / 2;
    this.zoomX = 1;
    this.zoomY = 1;
    this.drawZero = true;
    this.drawAuto = true;
    this.drawStatus = true;
  }

  SignalViewer.prototype.text = function(str, x, y, opt) {
    var color, fillStyle, font, lineWidth, o, ref, strokeStyle;
    if (opt == null) {
      opt = {};
    }
    ref = this.ctx, font = ref.font, lineWidth = ref.lineWidth, strokeStyle = ref.strokeStyle, fillStyle = ref.fillStyle;
    color = opt.color;
    if (color == null) {
      color = "black";
    }
    this.ctx.font = "35px";
    this.ctx.lineWidth = 4;
    this.ctx.strokeStyle = "white";
    this.ctx.strokeText(str, x, y);
    this.ctx.fillStyle = color;
    this.ctx.fillText(str, x, y);
    o = {
      font: font,
      lineWidth: lineWidth,
      strokeStyle: strokeStyle,
      fillStyle: fillStyle
    };
    Object.keys(o).forEach((function(_this) {
      return function(key) {
        return _this.ctx[key] = o[key];
      };
    })(this));
    return this;
  };

  SignalViewer.prototype.draw = function(f32arr, opt) {
    var _, arr, detail, i, max, min, ref, ref1, sampleRate;
    if (opt == null) {
      opt = {};
    }
    sampleRate = opt.sampleRate;
    arr = f32arr.map(function(v) {
      if (isFinite(v)) {
        return v;
      } else {
        return 0;
      }
    });
    if (sampleRate == null) {
      sampleRate = 44100;
    }
    ref = Signal.Statictics.findMax(arr), max = ref[0], _ = ref[1];
    ref1 = Signal.Statictics.findMin(arr), min = ref1[0], _ = ref1[1];
    if (this.drawAuto) {
      this.zoomX = this.cnv.width / arr.length;
      this.zoomY = this.cnv.height / (max - min + 0.0000001);
      this.offsetY = -min * this.zoomY;
    }
    if (this.drawZero) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, this.cnv.height - (this.zoomY * 0 + this.offsetY));
      this.ctx.lineTo(this.cnv.width, this.cnv.height - (this.zoomY * 0 + this.offsetY));
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.moveTo(this.offsetX, this.cnv.height - 0);
      this.ctx.lineTo(this.offsetX, this.cnv.height - this.cnv.height);
      this.ctx.stroke();
    }
    this.ctx.beginPath();
    this.ctx.moveTo(this.zoomX * (0 + this.offsetX), this.cnv.height - (this.zoomY * arr[0] + this.offsetY));
    i = 0;
    while (i++ < arr.length) {
      this.ctx.lineTo(this.zoomX * (i + this.offsetX), this.cnv.height - (this.zoomY * arr[i] + this.offsetY));
    }
    this.ctx.stroke();
    detail = {
      "sampleRate": sampleRate,
      "min": min,
      "max": max,
      "len": arr.length,
      "len(ms)": arr.length / sampleRate * 1000,
      "size": this.cnv.width + "x" + this.cnv.height
    };
    if (this.drawStatus) {
      Object.keys(detail).forEach((function(_this) {
        return function(key, i) {
          return _this.text((key + ":") + detail[key], 5, 15 + 10 * i);
        };
      })(this));
    }
    return this;
  };

  SignalViewer.prototype.drawSpectrogram = function(f32arr, opt) {
    var _, arr, b, buffer, detail, g, i, imgdata, index, j, k, l, len, len1, len2, m, max, ptr, r, ref, ref1, sampleRate, slideWidth, spectrum, spectrums, windowSize, x, y;
    if (opt == null) {
      opt = {};
    }
    sampleRate = opt.sampleRate, windowSize = opt.windowSize, slideWidth = opt.slideWidth, max = opt.max;
    arr = f32arr.map(function(v) {
      if (isFinite(v)) {
        return v;
      } else {
        return 0;
      }
    });
    if (sampleRate == null) {
      sampleRate = 44100;
    }
    if (windowSize == null) {
      windowSize = Math.pow(2, 8);
    }
    if (slideWidth == null) {
      slideWidth = Math.pow(2, 5);
    }
    if (max == null) {
      max = 255;
    }
    ptr = 0;
    spectrums = [];
    while (ptr + windowSize < arr.length) {
      buffer = arr.subarray(ptr, ptr + windowSize);
      if (buffer.length !== windowSize) {
        break;
      }
      spectrum = Signal.fft(buffer, sampleRate).spectrum;
      for (i = k = 0, len = spectrum.length; k < len; i = ++k) {
        _ = spectrum[i];
        spectrum[i] = spectrum[i] * 20000;
      }
      spectrums.push(spectrum);
      ptr += slideWidth;
    }
    this.cnv.width = spectrums.length;
    this.cnv.height = spectrums[0].length;
    imgdata = this.ctx.createImageData(spectrums.length, spectrums[0].length);
    for (i = l = 0, len1 = spectrums.length; l < len1; i = ++l) {
      _ = spectrums[i];
      for (j = m = 0, len2 = spectrum.length; m < len2; j = ++m) {
        _ = spectrum[j];
        ref = SignalViewer.hslToRgb(spectrums[i][j] / max, 0.5, 0.5), r = ref[0], g = ref[1], b = ref[2];
        ref1 = [i, imgdata.height - 1 - j], x = ref1[0], y = ref1[1];
        index = x + y * imgdata.width;
        imgdata.data[index * 4 + 0] = b | 0;
        imgdata.data[index * 4 + 1] = g | 0;
        imgdata.data[index * 4 + 2] = r | 0;
        imgdata.data[index * 4 + 3] = 255;
      }
    }
    this.ctx.putImageData(imgdata, 0, 0);
    detail = {
      "sampleRate": sampleRate,
      "windowSize": windowSize,
      "slideWidth": slideWidth,
      "windowSize(ms)": windowSize / sampleRate * 1000,
      "slideWidth(ms)": slideWidth / sampleRate * 1000,
      "ptr": 0 + "-" + (ptr - 1) + "/" + arr.length,
      "ms": 0 / sampleRate * 1000 + "-" + (ptr - 1) / sampleRate * 1000 + "/" + arr.length * 1000 / sampleRate,
      "reso": arr.length / slideWidth,
      "size": spectrums.length + "x" + spectrums[0].length
    };
    if (this.drawStatus) {
      Object.keys(detail).forEach((function(_this) {
        return function(key, i) {
          return _this.text((key + ":") + detail[key], 5, 15 + 10 * i);
        };
      })(this));
    }
    return this;
  };

  SignalViewer.prototype.appendTo = function(element) {
    element.appendChild(this.cnv);
    return this;
  };

  SignalViewer.hue2rgb = hue2rgb;

  SignalViewer.hslToRgb = hslToRgb;

  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1 / 6) { return p + (q - p) * 6 * t; }
    if (t < 1 / 2) { return q; }
    if (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6; }
    return p;
  }
  function hslToRgb(h, s, l) {
    // h, s, l: 0~1
    h *= 5 / 6;
    if (h < 0) {
      h = 0;
    }
    if (5 / 6 < h) {
      h = 5 / 6;
    }
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return [r * 255, g * 255, b * 255];
  };

  return SignalViewer;

})();
