// Generated by CoffeeScript 1.10.0
(function() {
  var Detector, POST_URL, RecordBuffer, VIEW_SIZE, Wave, getSignalImage, post;

  RecordBuffer = window["duxca"]["lib"]["RecordBuffer"];

  Wave = window["duxca"]["lib"]["Wave"];

  Detector = window["Detector"];

  POST_URL = "/php/file_upload.php";

  POST_URL = "/push";

  VIEW_SIZE = Math.pow(2, 12);

  this._Hoge = (function() {
    function _Hoge(actx, color) {
      this.actx = actx;
      this.color = color;
      this.isRecording = false;
      this.nextTick = null;
      this.pulseStartTime = {};
      this.pulseStopTime = {};
      this.processor = this.actx.createScriptProcessor(Math.pow(2, 14), 1, 1);
      this.processor.connect(this.actx.destination);
      this.processor.addEventListener("audioprocess", this.audioprocess.bind(this));
      this.gain = this.actx.createGain();
      this.gain.connect(this.actx.destination);
      this.recbuf = new RecordBuffer(this.actx.sampleRate, this.processor.bufferSize, this.processor.channelCount);
      this.detector = new Detector(this.actx);
      this.startStops = null;
      this.f32arr = null;
      this.int16arr = null;
      this.results = null;
    }

    _Hoge.prototype.audioprocess = function(ev) {
      var fn;
      if (this.isRecording) {
        this.recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], this.actx.currentTime);
      }
      if (this.nextTick instanceof Function) {
        fn = this.nextTick;
        this.nextTick = null;
        return fn();
      }
    };

    _Hoge.prototype.prepareRec = function(next) {
      var left, right;
      left = function(err) {
        throw err;
      };
      right = (function(_this) {
        return function(stream) {
          var source;
          source = _this.actx.createMediaStreamSource(stream);
          source.connect(_this.processor);
          return next();
        };
      })(this);
      return navigator.getUserMedia({
        video: false,
        audio: true
      }, right, left);
    };

    _Hoge.prototype.ready = function(data) {
      return (function(_this) {
        return function(next) {
          _this.recbuf.clear();
          return _this.detector.init(data, next);
        };
      })(this);
    };

    _Hoge.prototype.startRec = function(next) {
      this.isRecording = true;
      return next();
    };

    _Hoge.prototype.startPulse = function(id) {
      return (function(_this) {
        return function(next) {
          _this.pulseStartTime[id] = _this.actx.currentTime;
          return next();
        };
      })(this);
    };

    _Hoge.prototype.beepPulse = function(next) {
      return this.detector.beep(next);
    };

    _Hoge.prototype.stopPulse = function(id) {
      return (function(_this) {
        return function(next) {
          return _this.nextTick = function() {
            _this.pulseStopTime[id] = _this.actx.currentTime;
            return next();
          };
        };
      })(this);
    };

    _Hoge.prototype.stopRec = function(next) {
      this.isRecording = false;
      return next();
    };

    _Hoge.prototype.getStartStops = function() {
      var recStartTime, recStopTime, startStops;
      recStartTime = this.recbuf.sampleTimes[0] - (this.recbuf.bufferSize / this.recbuf.sampleRate);
      recStopTime = this.recbuf.sampleTimes[this.recbuf.sampleTimes.length - 1];
      startStops = Object.keys(this.pulseStartTime).map((function(_this) {
        return function(id) {
          var startPtr, stopPtr;
          startPtr = (_this.pulseStartTime[id] - recStartTime) * _this.recbuf.sampleRate | 0;
          stopPtr = (_this.pulseStopTime[id] - recStartTime) * _this.recbuf.sampleRate | 0;
          return {
            id: id,
            startPtr: startPtr,
            stopPtr: stopPtr
          };
        };
      })(this));
      return startStops;
    };

    _Hoge.prototype.calc = function(next) {
      this.startStops = this.getStartStops();
      this.f32arr = this.recbuf.merge();
      this.int16arr = this.recbuf.toPCM();
      this.results = this.detector.calc(this.f32arr, this.startStops);
      this.recbuf.clear();
      return next();
    };

    _Hoge.prototype.collect = function(data) {
      return (function(_this) {
        return function(next) {
          var color, experimentID, f32arr, id, int16arr, json, results, sampleRate, startStops, timeStamp, wave;
          experimentID = data.experimentID, timeStamp = data.timeStamp;
          id = socket.id;
          color = _this.color;
          startStops = _this.startStops;
          f32arr = _this.f32arr;
          int16arr = _this.int16arr;
          sampleRate = _this.actx.sampleRate;
          wave = new Wave(1, sampleRate, int16arr).toBlob();
          json = new Blob([
            JSON.stringify({
              sampleRate: sampleRate,
              startStops: startStops
            })
          ]);
          results = _this.results;
          return Promise.resolve().then(function() {
            return post(POST_URL, {
              filename: experimentID + "_" + timeStamp + "_" + color + "_" + id + ".json",
              file: json
            });
          }).then(function() {
            return post(POST_URL, {
              filename: experimentID + "_" + timeStamp + "_" + color + "_" + id + ".wav",
              file: wave
            });
          }).then(function() {
            var foldable;
            foldable = results.map(function(arg) {
              var images, results;
              images = arg.images, results = arg.results;
              return function() {
                var foldable2;
                foldable2 = Object.keys(images).map(function(filename) {
                  return function() {
                    return getSignalImage(images[filename]).then(function(img) {
                      return post(POST_URL, {
                        filename: experimentID + "_" + timeStamp + "_" + color + "_" + id + "_" + filename + ".jpg",
                        file: img
                      });
                    });
                  };
                });
                return foldable2.reduce((function(a, b) {
                  return a.then(function() {
                    return b();
                  });
                }), Promise.resolve());
              };
            });
            return foldable.reduce((function(a, b) {
              return a.then(function() {
                return b();
              });
            }), Promise.resolve());
          })["catch"](function(err) {
            console.error(err);
            return setTimeout(function() {
              throw err;
            });
          }).then(function() {
            return next({
              id: id,
              color: color,
              results: results.map(function(arg) {
                var results;
                results = arg.results;
                return results;
              })
            });
          });
        };
      })(this);
    };

    _Hoge.prototype.distribute = function(data) {
      return (function(_this) {
        return function(next) {
          data.forEach(function(arg) {
            var id, results;
            id = arg.id, results = arg.results;
            console.group(id);
            console.log(id);
            console.table(results);
            return console.groupEnd(id);
          });
          return next();
        };
      })(this);
    };

    _Hoge.prototype.play = function(data) {
      return console.log("play", data);
    };

    _Hoge.prototype.volume = function(data) {
      return console.log("volume", data);
    };

    return _Hoge;

  })();

  post = function(url, param) {
    var formData;
    formData = new FormData();
    Object.keys(param).forEach(function(key) {
      return formData.append(key, param[key]);
    });
    return $.ajax({
      type: 'POST',
      url: url,
      data: formData,
      contentType: false,
      processData: false
    }).promise();
  };

  getSignalImage = function(arr, cb) {
    return new Promise(function(resolve) {
      var render, width;
      width = VIEW_SIZE < arr.length ? VIEW_SIZE : arr.length;
      render = new SignalViewer(width, 64);
      render.draw(arr);
      return render.cnv.toBlob(resolve, "image/jpeg", 0.5);
    });
  };

}).call(this);
