// Generated by CoffeeScript 1.10.0
(function() {
  var HEIGHT, MULTIPASS_DISTANCE, RULED_LINE_INTERVAL, SOUND_OF_SPEED, TIME_DATA, VIEW_SIZE, VS, WIDTH, _craetePictureFrame, _processing, calc, main, points, socket;

  window["socket"] = socket = io(location.hostname + ":" + location.port + "/calc");

  socket.on("connect", console.info.bind(console, "connect"));

  socket.on("reconnect", console.info.bind(console, "reconnect"));

  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

  socket.on("reconnecting", console.info.bind(console, "reconnecting"));

  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

  socket.on("disconnect", console.info.bind(console, "disconnect"));

  socket.on("error", console.info.bind(console, "error"));

  socket.on("echo", console.info.bind(console, "echo"));

  socket.on("connect", function() {
    return socket.emit("colors");
  });

  WIDTH = 400;

  HEIGHT = 400;

  RULED_LINE_INTERVAL = 50;

  MULTIPASS_DISTANCE = 5;

  SOUND_OF_SPEED = 340;

  VIEW_SIZE = Math.pow(2, 12);

  TIME_DATA = null;

  VS = [0, 0, "VS"];

  points = [];

  main = function() {
    socket.on("calc", function(a) {
      return calc(a)(function() {
        return socket.emit("calc");
      });
    });
    socket.on("colors", function(datas) {
      console.log(datas);
      return points = datas.map(function(arg) {
        var color, id;
        id = arg.id, color = arg.color;
        return [Math.random() * (WIDTH - 100) + 50, Math.random() * (HEIGHT - 100) + 50, color, id];
      });
    });
    $("#start").click(function() {
      document.body.style.backgroundColor = "white";
      return socket.emit("start");
    });
    $("#colors").click(function() {
      return socket.emit("colors");
    });
    $("#play").click(function() {
      if (TIME_DATA == null) {
        return;
      }
      TIME_DATA.wait = 4;
      TIME_DATA.now2 = Date.now();
      console.log("TIME_DATA", TIME_DATA);
      return socket.emit("play", TIME_DATA);
    });
    return $("#status").click(function() {
      var R, _volumes, a, aliases, currentTimes, delayTimes, delayTimesAliased, distances, distancesAliased, distancesVS, id, k, now, now2, pulseTimes, pulseTimesAliased, recStartTimes, sum, volumes, wait;
      wait = 0;
      distances = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          o[id2] = Math.sqrt(Math.pow(x - _x, 2) + Math.pow(y - _y, 2));
          return o;
        }), {});
        return o;
      }), {});
      delayTimes = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          o[id2] = distances[id1][id2] * 2 / SOUND_OF_SPEED;
          return o;
        }), {});
        return o;
      }), {});
      pulseTimes = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          if (i === j) {
            o[id2] = 0;
          } else {
            o[id2] = 1;
          }
          return o;
        }), {});
        return o;
      }), {});
      recStartTimes = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = 0;
        return o;
      }), {});
      currentTimes = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = 2;
        return o;
      }), {});
      distancesVS = points.map(function(point) {
        var _x, _y, x, y;
        x = point[0], y = point[1];
        _x = VS[0], _y = VS[1];
        return Math.sqrt(Math.pow(x - _x, 2) + Math.pow(y - _y, 2));
      });
      R = 6;
      a = R / (20 * Math.log10(2));
      sum = distancesVS.reduce((function(a, d) {
        return a + 1 / Math.pow(d, 2 * a);
      }), 0);
      k = 1 / Math.sqrt(sum);
      _volumes = distancesVS.map(function(d) {
        return k / Math.pow(d, a);
      });
      volumes = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = _volumes[i];
        return o;
      }), {});
      now = Date.now();
      now2 = Date.now();
      id = points[0][3];
      aliases = points.reduce((function(o, arg) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[id1] = color1;
        return o;
      }), {});
      distancesAliased = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[aliases[id1]] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          o[aliases[id2]] = distances[id1][id2];
          return o;
        }), {});
        return o;
      }), {});
      delayTimesAliased = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[aliases[id1]] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          o[aliases[id2]] = delayTimes[id1][id2];
          return o;
        }), {});
        return o;
      }), {});
      pulseTimesAliased = points.reduce((function(o, arg, i) {
        var color1, id1, x, y;
        x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
        o[aliases[id1]] = points.reduce((function(o, arg1, j) {
          var _x, _y, color2, id2;
          _x = arg1[0], _y = arg1[1], color2 = arg1[2], id2 = arg1[3];
          o[aliases[id2]] = pulseTimes[id1][id2];
          return o;
        }), {});
        return o;
      }), {});
      console.info("pulseTimesAliased");
      console.table(pulseTimesAliased);
      console.info("delayTimesAliased");
      console.table(delayTimesAliased);
      console.info("distancesAliased");
      return console.table(distancesAliased);
    });
  };

  calc = function(datas) {
    return function(next) {
      var K, aliases, basePt, currentTimes, delayTimes, delayTimesAliased, distances, distancesAliased, ds, frame, now, pseudoPts, pulseTimes, pulseTimesAliased, recStartTimes, relDelayTimes, relDelayTimesAliased, results, sampleRates, sdm;
      if (datas.length === 0) {
        return next();
      }
      now = Date.now();
      frame = _craetePictureFrame("calc", document.body);
      aliases = datas.reduce((function(o, arg) {
        var alias, id;
        id = arg.id, alias = arg.alias;
        o[id] = alias;
        return o;
      }), {});
      results = datas.map(function(arg) {
        var DSSS_SPEC, _frame, _results, alias, carrier_freq, id, length, matched, recF32arr, sampleRate, seed, ss_code, startStops;
        id = arg.id, alias = arg.alias, startStops = arg.startStops, recF32arr = arg.recF32arr, DSSS_SPEC = arg.DSSS_SPEC, sampleRate = arg.sampleRate;
        length = DSSS_SPEC.length, seed = DSSS_SPEC.seed, carrier_freq = DSSS_SPEC.carrier_freq;
        _frame = _craetePictureFrame(alias + "@" + id);
        frame.add(_frame.element);
        ss_code = Signal.mseqGen(length, seed);
        matched = Signal.BPSK(ss_code, carrier_freq, sampleRate, 0);
        recF32arr = new Float32Array(recF32arr);
        console.log(recF32arr.length, alias);
        _results = startStops.map(function(arg1) {
          var T, __frame, _id, ave, begin, cutoff, end, flag, idx, l, len, low_section_matched_range, marker, max_offset, mse_section_matched_range, offset, pulseTime, range, ref, section, section_matched, section_matched_range, space, startPtr, stdscore_section_matched_range, stopPtr, threshold, v, val, vari;
          _id = arg1.id, startPtr = arg1.startPtr, stopPtr = arg1.stopPtr;
          console.log(_id, startPtr, stopPtr);
          __frame = _craetePictureFrame(aliases[id] + "<->" + aliases[_id]);
          _frame.add(__frame.element);
          T = matched.length;
          section = recF32arr.subarray(startPtr, stopPtr);
          __frame.view(section, "section");
          space = new Float32Array(section.length * 2);
          space.set(section, 0);
          section_matched = Signal.fft_smart_overwrap_correlation(space, matched);
          section_matched = section_matched.subarray(0, section.length);
          section_matched.forEach(function(_, i) {
            return section_matched[i] = section_matched[i] * section_matched[i];
          });
          __frame.view(section_matched, "section * matched");
          __frame.text((ref = Signal.Statictics.findMax(section_matched), val = ref[0], idx = ref[1], ref));
          range = MULTIPASS_DISTANCE / SOUND_OF_SPEED * sampleRate | 0;
          begin = idx - range;
          if (begin < 0) {
            begin = 0;
          }
          end = idx + range;
          marker = new Uint8Array(section_matched.length);
          marker[begin] = marker[end] = 255;
          __frame.view(marker, "marker");
          section_matched_range = section_matched.subarray(begin, end);
          __frame.view(section_matched_range, "section * matched, range" + MULTIPASS_DISTANCE);
          mse_section_matched_range = section_matched_range.map(function(a) {
            return a * a;
          });
          __frame.view(mse_section_matched_range, "section * matched, square");
          cutoff = 1000;
          low_section_matched_range = Signal.lowpass(mse_section_matched_range, sampleRate, cutoff, 1);
          __frame.view(low_section_matched_range, "section * matched, lowpass" + cutoff);
          vari = Signal.Statictics.variance(low_section_matched_range);
          ave = Signal.Statictics.average(low_section_matched_range);
          threshold = 78;
          stdscore_section_matched_range = low_section_matched_range.map(function(x) {
            return 10 * (x - ave) / vari + RULED_LINE_INTERVAL;
          });
          flag = true;
          while (flag) {
            for (offset = l = 0, len = stdscore_section_matched_range.length; l < len; offset = ++l) {
              v = stdscore_section_matched_range[offset];
              if (threshold < stdscore_section_matched_range[offset]) {
                flag = false;
                break;
              }
            }
            threshold -= 1;
          }
          marker = new Uint8Array(low_section_matched_range.length);
          marker[offset] = 255;
          __frame.view(marker, "offset" + offset);
          max_offset = begin + offset;
          pulseTime = (startPtr + max_offset) / sampleRate;
          return {
            id: _id,
            max_offset: max_offset,
            pulseTime: pulseTime
          };
        });
        return {
          id: id,
          alias: alias,
          results: _results
        };
      });
      sampleRates = datas.reduce((function(o, arg) {
        var id, sampleRate;
        id = arg.id, sampleRate = arg.sampleRate;
        o[id] = sampleRate;
        return o;
      }), {});
      recStartTimes = datas.reduce((function(o, arg) {
        var id, recStartTime;
        id = arg.id, recStartTime = arg.recStartTime;
        o[id] = recStartTime;
        return o;
      }), {});
      currentTimes = datas.reduce((function(o, arg) {
        var currentTime, id;
        id = arg.id, currentTime = arg.currentTime;
        o[id] = currentTime;
        return o;
      }), {});
      pulseTimes = {};
      relDelayTimes = {};
      delayTimes = {};
      distances = {};
      relDelayTimesAliased = {};
      distancesAliased = {};
      delayTimesAliased = {};
      pulseTimesAliased = {};
      results.forEach(function(arg) {
        var alias, id, results;
        id = arg.id, alias = arg.alias, results = arg.results;
        return results.forEach(function(arg1) {
          var _id, max_offset, pulseTime;
          _id = arg1.id, max_offset = arg1.max_offset, pulseTime = arg1.pulseTime;
          pulseTimes[id] = pulseTimes[id] || {};
          pulseTimes[id][_id] = pulseTime;
          pulseTimesAliased[aliases[id]] = pulseTimesAliased[aliases[id]] || {};
          return pulseTimesAliased[aliases[id]][aliases[_id]] = pulseTimes[id][_id];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          relDelayTimes[id1] = relDelayTimes[id1] || {};
          relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
          relDelayTimesAliased[aliases[id1]] = relDelayTimesAliased[aliases[id1]] || {};
          return relDelayTimesAliased[aliases[id1]][aliases[id2]] = relDelayTimes[id1][id2];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          delayTimes[id1] = delayTimes[id1] || {};
          delayTimes[id1][id2] = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
          delayTimesAliased[aliases[id1]] = delayTimesAliased[aliases[id1]] || {};
          delayTimesAliased[aliases[id1]][aliases[id2]] = delayTimes[id1][id2];
          distances[id1] = distances[id1] || {};
          distances[id1][id2] = Math.abs(delayTimes[id1][id2]) / 2 * SOUND_OF_SPEED;
          distancesAliased[aliases[id1]] = distancesAliased[aliases[id1]] || {};
          return distancesAliased[aliases[id1]][aliases[id2]] = distances[id1][id2];
        });
      });
      if (console.table != null) {
        console.group("table");
        console.info("recStartTimes", recStartTimes);
        console.info("pulseTimesAliased");
        console.table(pulseTimesAliased);
        console.info("relDelayTimesAliased");
        console.table(relDelayTimesAliased);
        console.info("delayTimesAliased");
        console.table(delayTimesAliased);
        console.info("distancesAliased");
        console.table(distancesAliased);
        console.groupEnd();
      }
      ds = Object.keys(delayTimes).map(function(id1) {
        return Object.keys(delayTimes).map(function(id2) {
          return distances[id1][id2];
        });
      });
      pseudoPts = results.map(function(arg, i) {
        var id1;
        id1 = arg.id1;
        return new Point(Math.random() * 10, Math.random() * 10);
      });
      sdm = new SDM(pseudoPts, ds);
      K = 0;
      while (K++ < 200) {
        sdm.step();
      }
      basePt = sdm.points[0];
      points = sdm.points.map(function(pt, i) {
        return [
          WIDTH / 2 + (pt.x - basePt.x) * 50, HEIGHT / 2 + (pt.y - basePt.y) * 50, results.map(function(arg, i) {
            var alias;
            alias = arg.alias;
            return alias;
          })[i], results.map(function(arg, i) {
            var id;
            id = arg.id;
            return id;
          })[i]
        ];
      });
      document.body.style.backgroundColor = "lime";
      TIME_DATA = {
        pulseTimes: pulseTimes,
        delayTimes: delayTimes,
        aliases: aliases,
        recStartTimes: recStartTimes,
        now: now,
        currentTimes: currentTimes,
        id: results[0].id
      };
      return next();
    };
  };

  _processing = function(next) {
    var drgTrgPtr;
    drgTrgPtr = null;
    new Processing($("#_cnv_")[0], function(_) {
      _.mousePressed = function() {
        var i, l, len, point, ref, results1, x, y;
        ref = [].concat([VS], points);
        results1 = [];
        for (i = l = 0, len = ref.length; l < len; i = ++l) {
          point = ref[i];
          x = point[0], y = point[1];
          if (Math.abs(x - _.mouseX) < 25 && Math.abs(y - _.mouseY) < 25) {
            drgTrgPtr = point;
            break;
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      };
      _.mouseReleased = function() {
        return drgTrgPtr = null;
      };
      _.setup = function() {
        _.size(WIDTH, HEIGHT);
        return VS = [50, 50, "VS", "VS"];
      };
      return _.draw = function() {
        var R, __l, __x, __y, _volumes, _x, _y, a, distancesVS, i, id, j, k, l, len, len1, m, n, name, point, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, sum, volumes, x, y;
        if (drgTrgPtr != null) {
          drgTrgPtr[0] = _.mouseX;
          drgTrgPtr[1] = _.mouseY;
          distancesVS = points.map(function(point) {
            var _x, _y, x, y;
            x = point[0], y = point[1];
            _x = VS[0], _y = VS[1];
            return Math.sqrt(Math.pow(x - _x, 2) + Math.pow(y - _y, 2));
          });
          R = 6;
          a = R / (20 * Math.log10(2));
          sum = distancesVS.reduce((function(a, d) {
            return a + 1 / Math.pow(d, 2 * a);
          }), 0);
          k = 1 / Math.sqrt(sum);
          _volumes = distancesVS.map(function(d) {
            return k / Math.pow(d, a);
          });
          volumes = points.reduce((function(o, arg, i) {
            var color1, id1, x, y;
            x = arg[0], y = arg[1], color1 = arg[2], id1 = arg[3];
            o[id1] = _volumes[i];
            return o;
          }), {});
          socket.emit("volume", volumes);
        }
        _.background(255);
        _.stroke(127);
        for (i = l = ref = RULED_LINE_INTERVAL, ref1 = _.width, ref2 = RULED_LINE_INTERVAL; ref2 > 0 ? l <= ref1 : l >= ref1; i = l += ref2) {
          _.line(0, i, _.width, i);
        }
        for (i = m = ref3 = RULED_LINE_INTERVAL, ref4 = _.height, ref5 = RULED_LINE_INTERVAL; ref5 > 0 ? m <= ref4 : m >= ref4; i = m += ref5) {
          _.line(i, 0, i, _.height);
        }
        _.stroke(0);
        for (i = n = 0, len = points.length; n < len; i = ++n) {
          point = points[i];
          x = point[0], y = point[1];
          for (j = q = ref6 = i, ref7 = points.length; ref6 <= ref7 ? q < ref7 : q > ref7; j = ref6 <= ref7 ? ++q : --q) {
            if (!(i !== j)) {
              continue;
            }
            ref8 = points[j], _x = ref8[0], _y = ref8[1];
            _.line(x, y, _x, _y);
            __x = ((x - _x) / 2) + _x;
            __y = ((y - _y) / 2) + _y;
            __l = Math.sqrt(Math.pow(x - _x, 2) + Math.pow(y - _y, 2));
            _.text((__l / RULED_LINE_INTERVAL * 100 | 0) / 100, __x, __y);
          }
        }
        for (i = r = 0, len1 = points.length; r < len1; i = ++r) {
          point = points[i];
          x = point[0], y = point[1], name = point[2], id = point[3];
          _.fill(255);
          _.ellipse(x, y, 25, 25);
          _.fill(0);
          _.text(name, x + 10, y - 10);
          _.text((x | 0) + ", " + (y | 0), x + 10, y + 10);
        }
        x = VS[0], y = VS[1], name = VS[2];
        _.fill(128);
        _.ellipse(x, y, 25, 25);
        _.fill(0);
        _.text(name, x - 3, y + 5);
        _.text((x | 0) + ", " + (y | 0), x + 10, y + 10);
      };
    });
    return next();
  };

  _craetePictureFrame = function(description, target) {
    var fieldset, legend, style;
    fieldset = document.createElement('fieldset');
    style = document.createElement('style');
    style.appendChild(document.createTextNode("canvas,img{border:1px solid black;}"));
    style.setAttribute("scoped", "scoped");
    fieldset.appendChild(style);
    legend = document.createElement('legend');
    legend.appendChild(document.createTextNode(description));
    fieldset.appendChild(legend);
    fieldset.style.display = 'inline-block';
    fieldset.style.backgroundColor = "white";
    if (target != null) {
      target.appendChild(fieldset);
    }
    return {
      element: fieldset,
      add: function(element) {
        var p, txtNode;
        if (typeof element === "string") {
          txtNode = document.createTextNode(element);
          p = document.createElement("p");
          p.appendChild(txtNode);
          return fieldset.appendChild(p);
        } else {
          return fieldset.appendChild(element);
        }
      },
      view: function(arr, title) {
        var __frame, render, width;
        __frame = _craetePictureFrame(title + ("(" + arr.length + ")"));
        width = VIEW_SIZE < arr.length ? VIEW_SIZE : arr.length;
        render = new Signal.Render(width, 64);
        Signal.Render.prototype.drawSignal.apply(render, [arr, true, true]);
        __frame.add(render.element);
        this.add(__frame.element);
        return this.add(document.createElement("br"));
      },
      text: function(title) {
        this.add(document.createTextNode(title));
        return this.add(document.createElement("br"));
      }
    };
  };

  window.addEventListener("DOMContentLoaded", function() {
    return _processing(function() {
      return main();
    });
  });

}).call(this);
