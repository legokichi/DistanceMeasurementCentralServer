// Generated by CoffeeScript 1.10.0
(function() {
  var DSSS_SPEC, TEST_INPUT_MYSELF, VOLUME, __nextTick__, _prepareRec, _prepareSpect, actx, analyser, beepPulse, changeColor, gain, isBroadcasting, isRecording, main, osc, play, processor, pulseStartTime, pulseStopTime, ready, recbuf, sendRec, set_vs_weight, socket, startPulse, startRec, stopPulse, stopRec;

  window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;

  changeColor = function() {
    return document.body.style.backgroundColor = location.hash.slice(1);
  };

  window.addEventListener("DOMContentLoaded", changeColor);

  window.addEventListener("hashchange", changeColor);

  window["socket"] = socket = io(location.hostname + ":" + location.port + "/node");

  socket.on("connect", console.info.bind(console, "connect"));

  socket.on("reconnect", console.info.bind(console, "reconnect"));

  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

  socket.on("reconnecting", console.info.bind(console, "reconnecting"));

  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

  socket.on("disconnect", console.info.bind(console, "disconnect"));

  socket.on("error", console.info.bind(console, "error"));

  socket.on("echo", console.info.bind(console, "echo"));

  socket.on("connect", function() {
    return socket.emit("echo", socket.id);
  });

  window.onerror = function(err) {
    var pre, textnode;
    console.error(err, err != null ? err.stack : void 0);
    document.body.style.backgroundColor = "gray";
    pre = document.createElement("pre");
    textnode = document.createTextNode(err.stack || err);
    pre.appendChild(textnode);
    return document.body.appendChild(pre);
  };

  actx = new AudioContext();

  osc = new OSC(actx);

  analyser = actx.createAnalyser();

  analyser.smoothingTimeConstant = 0;

  analyser.fftSize = 512;

  processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

  gain = actx.createGain();

  gain.connect(actx.destination);

  TEST_INPUT_MYSELF = false;

  recbuf = null;

  isRecording = false;

  isBroadcasting = false;

  pulseStartTime = {};

  pulseStopTime = {};

  DSSS_SPEC = null;

  VOLUME = 1;

  __nextTick__ = null;

  main = function() {
    socket.on("ready", function(a) {
      return ready(a)(function() {
        return socket.emit("ready");
      });
    });
    socket.on("startRec", function() {
      return startRec(function() {
        return socket.emit("startRec");
      });
    });
    socket.on("startPulse", function(a) {
      return startPulse(a)(function() {
        return socket.emit("startPulse");
      });
    });
    socket.on("beepPulse", function() {
      return beepPulse(function() {
        return socket.emit("beepPulse");
      });
    });
    socket.on("stopPulse", function(a) {
      return stopPulse(a)(function() {
        return socket.emit("stopPulse");
      });
    });
    socket.on("stopRec", function() {
      return stopRec(function() {
        return socket.emit("stopRec");
      });
    });
    socket.on("sendRec", function() {
      return sendRec(function(a) {
        return socket.emit("sendRec", a);
      });
    });
    socket.on("play", function(a) {
      return play(a)(function() {
        return socket.emit("play");
      });
    });
    return socket.on("set_vs_weight", function(a) {
      return set_vs_weight(a)(function() {
        return socket.emit("set_vs_weight");
      });
    });
  };

  ready = function(arg) {
    var PULSE_N, carrier_freq, isChirp, length, powL, seed;
    length = arg.length, seed = arg.seed, carrier_freq = arg.carrier_freq, isChirp = arg.isChirp, powL = arg.powL, PULSE_N = arg.PULSE_N;
    return function(next) {
      var abuf, matched, n, ss_code, ss_sig;
      n = function(a) {
        return a.split("").map(Number);
      };
      document.body.style.backgroundColor = location.hash.slice(1);
      recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
      isRecording = false;
      isBroadcasting = false;
      pulseStartTime = {};
      pulseStopTime = {};
      DSSS_SPEC = null;
      __nextTick__ = null;
      ss_code = Signal.mseqGen(length, seed);
      matched = Signal.BPSK(ss_code, carrier_freq, actx.sampleRate, 0);
      ss_sig = matched;
      abuf = osc.createAudioBufferFromArrayBuffer(ss_sig, actx.sampleRate);
      DSSS_SPEC = {
        abuf: abuf,
        length: length,
        seed: seed,
        carrier_freq: carrier_freq,
        isChirp: isChirp,
        powL: powL,
        PULSE_N: PULSE_N
      };
      VOLUME = 1;
      (function() {
        var coms, corr;
        corr = Signal.fft_smart_overwrap_correlation(ss_sig, matched);
        return coms = [[matched, true, true], [ss_sig, true, true], [corr, true, true]].forEach(function(com, i) {
          var render;
          render = new Signal.Render(com[0].length / 100, 64);
          Signal.Render.prototype.drawSignal.apply(render, com);
          document.body.appendChild(render.element);
          return document.body.appendChild(document.createElement("br"));
        });
      });
      return next();
    };
  };

  startRec = function(next) {
    isRecording = true;
    return __nextTick__ = function() {
      __nextTick__ = null;
      return next();
    };
  };

  startPulse = function(id) {
    return function(next) {
      pulseStartTime[id] = actx.currentTime;
      return next();
    };
  };

  beepPulse = function(next) {
    var abuf, anode, recur, startTime;
    abuf = DSSS_SPEC.abuf;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    if (TEST_INPUT_MYSELF) {
      anode.connect(processor);
      anode.connect(analyser);
    } else {
      anode.connect(actx.destination);
    }
    anode.start(actx.currentTime);
    startTime = actx.currentTime;
    return (recur = function() {
      if ((startTime + abuf.duration) < actx.currentTime) {
        return setTimeout(next, 100);
      } else {
        return setTimeout(recur, 100);
      }
    })();
  };

  stopPulse = function(id) {
    return function(next) {
      return __nextTick__ = function() {
        pulseStopTime[id] = actx.currentTime;
        __nextTick__ = null;
        return next();
      };
    };
  };

  stopRec = function(next) {
    isRecording = false;
    return next();
  };

  sendRec = function(next) {
    var f32arr, o, recStartTime, recStopTime, startStops;
    f32arr = recbuf.merge();
    recStartTime = recbuf.sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
    recStopTime = recbuf.sampleTimes[recbuf.sampleTimes.length - 1];
    startStops = Object.keys(pulseStartTime).map(function(id) {
      var startPtr, stopPtr;
      startPtr = (pulseStartTime[id] - recStartTime) * recbuf.sampleRate | 0;
      stopPtr = (pulseStopTime[id] - recStartTime) * recbuf.sampleRate | 0;
      return {
        id: id,
        startPtr: startPtr,
        stopPtr: stopPtr
      };
    });
    o = {
      id: socket.id,
      recStartTime: recStartTime,
      recStopTime: recStopTime,
      alias: location.hash.slice(1),
      startStops: startStops,
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      DSSS_SPEC: DSSS_SPEC,
      currentTime: actx.currentTime
    };
    recbuf.clear();
    return next(o);
  };

  play = function(data) {
    return function(next) {
      var currentTimes, delayTimes, id, matched, now, now2, offsetTime, pulseTimes, recStartTimes, wait;
      wait = data.wait, pulseTimes = data.pulseTimes, delayTimes = data.delayTimes, id = data.id, currentTimes = data.currentTimes, recStartTimes = data.recStartTimes, now = data.now, now2 = data.now2;
      offsetTime = recStartTimes[socket.id] + (pulseTimes[socket.id][id] - delayTimes[socket.id][id]) + (currentTimes[id] - (pulseTimes[id][id] + recStartTimes[id])) + (now2 - now) / 1000 + wait + 3;
      matched = Signal.BPSK([1, 1, 1, 1, 1], 2000, actx.sampleRate, 0, actx.sampleRate * 1);
      (function() {
        var abuf;
        abuf = osc.createAudioBufferFromArrayBuffer(matched, actx.sampleRate);
        return setTimeout((function() {
          var node;
          node = osc.createAudioNodeFromAudioBuffer(abuf);
          node.start(offsetTime + 1);
          node.loop = false;
          node.connect(gain);
          return next();
        }), 2000);
      });
      return osc.createAudioBufferFromURL("./TellYourWorld1min.mp3").then(function(abuf) {
        return setTimeout((function() {
          var node;
          node = osc.createAudioNodeFromAudioBuffer(abuf);
          node.start(offsetTime + 1);
          node.loop = false;
          node.connect(gain);
          return next();
        }), 2000);
      });
    };
  };

  set_vs_weight = function(data) {
    return function(next) {
      gain.gain.value = data[socket.id];
      return next();
    };
  };

  _prepareRec = function(next) {
    var left, right;
    left = function(err) {
      throw err;
    };
    right = function(stream) {
      var source;
      source = actx.createMediaStreamSource(stream);
      if (!TEST_INPUT_MYSELF) {
        source.connect(processor);
        source.connect(analyser);
      }
      processor.connect(actx.destination);
      processor.addEventListener("audioprocess", function(ev) {
        if (isRecording) {
          recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
        }
        if (__nextTick__ != null) {
          return __nextTick__();
        }
      });
      return next();
    };
    return navigator.getUserMedia({
      video: false,
      audio: true
    }, right, left);
  };

  _prepareSpect = function(next) {
    var i, render, rndr, spectrums;
    return next();
    spectrums = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 0, ref = analyser.frequencyBinCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results.push(new Uint8Array(analyser.frequencyBinCount));
      }
      return results;
    })();
    rndr = new Signal.Render(spectrums.length, spectrums[0].length);
    document.body.appendChild(rndr.element);
    (render = function() {
      var spectrum;
      spectrum = spectrums.shift();
      analyser.getByteFrequencyData(spectrum);
      spectrums.push(spectrum);
      rndr.drawSpectrogram(spectrums);
      return requestAnimationFrame(render);
    })();
    return next();
  };

  window.addEventListener("DOMContentLoaded", function() {
    return _prepareRec(function() {
      return _prepareSpect(function() {
        return main();
      });
    });
  });

}).call(this);
