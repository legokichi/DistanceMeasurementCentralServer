// Generated by CoffeeScript 1.10.0
(function() {
  var DSSS_SPEC, MULTIPASS_DISTANCE, PULSE_N, SOUND_OF_SPEED, VIEW_SIZE, _craetePictureFrame, _lowpass, _prepareRec, _prepareSpect, actx, analyser, beepPulse, changeColor, collect, isBroadcasting, isRecording, main, osc, processor, pulseStartTime, pulseStopTime, ready, recbuf, sendRec, socket, startPulse, startRec, stopPulse, stopRec;

  window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;

  changeColor = function() {
    return document.body.style.backgroundColor = location.hash.slice(1);
  };

  window.addEventListener("DOMContentLoaded", changeColor);

  window.addEventListener("hashchange", changeColor);

  window["socket"] = socket = io(location.hostname + ":" + location.port);

  socket.on("connect", console.info.bind(console, "connect"));

  socket.on("reconnect", console.info.bind(console, "reconnect"));

  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

  socket.on("reconnecting", console.info.bind(console, "reconnecting"));

  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

  socket.on("disconnect", console.info.bind(console, "disconnect"));

  socket.on("error", console.info.bind(console, "error"));

  socket.on("echo", console.info.bind(console, "echo"));

  socket.on("connect", function() {
    return socket.emit("echo", "hello");
  });

  window.onerror = function(err) {
    var pre, textnode;
    console.error(err, err != null ? err.stack : void 0);
    document.body.style.backgroundColor = "gray";
    pre = document.createElement("pre");
    textnode = document.createTextNode(err.stack || err);
    pre.appendChild(textnode);
    return document.body.appendChild(pre);
  };

  VIEW_SIZE = Math.pow(2, 10);

  actx = new AudioContext();

  osc = new OSC(actx);

  analyser = actx.createAnalyser();

  analyser.smoothingTimeConstant = 0;

  analyser.fftSize = 512;

  processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

  MULTIPASS_DISTANCE = 5;

  SOUND_OF_SPEED = 340;

  PULSE_N = 2;

  recbuf = null;

  isRecording = false;

  isBroadcasting = false;

  pulseStartTime = {};

  pulseStopTime = {};

  DSSS_SPEC = null;

  main = function() {
    socket.on("ready", function(a) {
      return ready(a)(function() {
        return socket.emit("ready");
      });
    });
    socket.on("startRec", function() {
      return startRec(function() {
        return socket.emit("startRec");
      });
    });
    socket.on("startPulse", function(a) {
      return startPulse(a)(function() {
        return socket.emit("startPulse");
      });
    });
    socket.on("beepPulse", function() {
      return beepPulse(function() {
        return socket.emit("beepPulse");
      });
    });
    socket.on("stopPulse", function(a) {
      return stopPulse(a)(function() {
        return socket.emit("stopPulse");
      });
    });
    socket.on("stopRec", function() {
      return stopRec(function() {
        return socket.emit("stopRec");
      });
    });
    socket.on("sendRec", function() {
      return sendRec(function(a) {
        return socket.emit("sendRec", a);
      });
    });
    return socket.on("collect", function(a) {
      return collect(a)(function() {
        return socket.emit("collect");
      });
    });
  };

  ready = function(arg) {
    var carrier_freq, isChirp, length, powL, seed;
    length = arg.length, seed = arg.seed, carrier_freq = arg.carrier_freq, isChirp = arg.isChirp, powL = arg.powL;
    return function(next) {
      var abuf, matched, n, ss_code, ss_sig;
      n = function(a) {
        return a.split("").map(Number);
      };
      document.body.style.backgroundColor = location.hash.slice(1);
      recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
      isRecording = false;
      isBroadcasting = false;
      pulseStartTime = {};
      pulseStopTime = {};
      DSSS_SPEC = null;
      if (isChirp) {
        console.log(ss_code = Signal.mseqGen(length, seed));
        return osc.resampling(Signal.createCodedChirp(ss_code, powL), 14).then(function(matched) {
          var abuf;
          abuf = osc.createAudioBufferFromArrayBuffer(matched, actx.sampleRate);
          DSSS_SPEC = {
            abuf: abuf,
            matched: matched.buffer
          };
          return next();
        });
      } else {
        ss_code = Signal.mseqGen(length, seed);
        matched = Signal.BPSK(ss_code, carrier_freq, actx.sampleRate, 0);
        ss_sig = Signal.BPSK(ss_code, carrier_freq, actx.sampleRate, 0, matched.length * PULSE_N);
        abuf = osc.createAudioBufferFromArrayBuffer(ss_sig, actx.sampleRate);
        DSSS_SPEC = {
          abuf: abuf,
          matched: matched.buffer
        };
        console.log(matched.length, ss_sig.length, abuf);
        (function() {
          var coms, corr;
          corr = Signal.fft_smart_overwrap_correlation(ss_sig, matched);
          return coms = [[matched, true, true], [ss_sig, true, true], [corr, true, true]].forEach(function(com, i) {
            var render;
            render = new Signal.Render(com[0].length / 100, 64);
            Signal.Render.prototype.drawSignal.apply(render, com);
            document.body.appendChild(render.element);
            return document.body.appendChild(document.createElement("br"));
          });
        });
        return next();
      }
    };
  };

  startRec = function(next) {
    isRecording = true;
    return next();
  };

  startPulse = function(id) {
    return function(next) {
      pulseStartTime[id] = actx.currentTime;
      return next();
    };
  };

  beepPulse = function(next) {
    var abuf, anode, recur;
    abuf = DSSS_SPEC.abuf;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    anode.connect(actx.destination);
    anode.start(actx.currentTime);
    return setTimeout((recur = function() {
      if (recbuf.chsBuffers[0].length > Math.ceil(abuf.length / processor.bufferSize)) {
        return next();
      } else {
        return setTimeout(recur, 100);
      }
    }), abuf.duration * 1.1 * 1000);
  };

  stopPulse = function(id) {
    return function(next) {
      pulseStopTime[id] = actx.currentTime;
      return next();
    };
  };

  stopRec = function(next) {
    isRecording = false;
    return next();
  };

  sendRec = function(next) {
    var f32arr, o, recStartTime, recStopTime, startStops;
    f32arr = recbuf.merge();
    recStartTime = recbuf.sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
    recStopTime = recbuf.sampleTimes[recbuf.sampleTimes.length - 1];
    startStops = Object.keys(pulseStartTime).map(function(id) {
      var startPtr, stopPtr;
      startPtr = (pulseStartTime[id] - recStartTime) * recbuf.sampleRate;
      stopPtr = (pulseStopTime[id] - recStartTime) * recbuf.sampleRate;
      return {
        id: id,
        startPtr: startPtr,
        stopPtr: stopPtr
      };
    });
    o = {
      id: socket.id,
      alias: location.hash.slice(1),
      startStops: startStops,
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      DSSS_SPEC: DSSS_SPEC
    };
    recbuf.clear();
    return next(o);
  };

  collect = function(datas) {
    return function(next) {
      var K, aliases, basePt, delayTimes, distances, distancesAliased, ds, frame_, pseudoPts, pulseTimes, relDelayTimes, render, results, sampleRates, sdm;
      if (location.hash.slice(1) !== "red") {
        return next();
      }
      console.info("calcCorrel");
      console.time("calcCorrel");
      frame_ = _craetePictureFrame("");
      document.body.appendChild(frame_.element);
      aliases = datas.reduce((function(o, arg) {
        var alias, id;
        id = arg.id, alias = arg.alias;
        o[id] = alias;
        return o;
      }), {});
      results = datas.map(function(arg) {
        var DSSS_SPEC, _results, alias, frame, id, recF32arr, sampleRate, startStops;
        id = arg.id, alias = arg.alias, startStops = arg.startStops, recF32arr = arg.recF32arr, DSSS_SPEC = arg.DSSS_SPEC, sampleRate = arg.sampleRate;
        frame = _craetePictureFrame(alias + "@" + id);
        frame_.add(frame.element);
        _results = startStops.map(function(arg1) {
          var S, T, _, _S, _frame, _id, _idxS, coms, correl, correls, idxS, j, k, marker, marker2, marker3, matched, max_offset, pulseTime, range, ref, ref1, results1, results2, section, startPtr, stopPtr;
          _id = arg1.id, startPtr = arg1.startPtr, stopPtr = arg1.stopPtr;
          section = new Float32Array(recF32arr).subarray(startPtr, stopPtr);
          matched = new Float32Array(DSSS_SPEC.matched);
          correl = Signal.fft_smart_overwrap_correlation(section, matched);
          T = matched.length;
          correls = (function() {
            results1 = [];
            for (var j = 1; 1 <= PULSE_N ? j <= PULSE_N : j >= PULSE_N; 1 <= PULSE_N ? j++ : j--){ results1.push(j); }
            return results1;
          }).apply(this).map(function(_, i) {
            return correl.subarray(T * i, T * i + T);
          });
          S = new Float32Array(T);
          S.forEach(function(_, i) {
            return S[i] = correls.reduce((function(a, correl) {
              return a + correl[i];
            }), 0);
          });
          ref = Signal.Statictics.findMax(S), _ = ref[0], idxS = ref[1];
          range = MULTIPASS_DISTANCE / SOUND_OF_SPEED * actx.sampleRate | 0;
          _S = S.subarray(idxS - range, idxS + range);
          max_offset = idxS;
          pulseTime = (startPtr + max_offset) / sampleRate;
          _frame = _craetePictureFrame(aliases[id] + "<->" + aliases[_id]);
          frame.add(_frame.element);
          marker = new Uint8Array(correl.length);
          (function() {
            results2 = [];
            for (var k = 1; 1 <= PULSE_N ? k <= PULSE_N : k >= PULSE_N; 1 <= PULSE_N ? k++ : k--){ results2.push(k); }
            return results2;
          }).apply(this).map(function(_, i) {
            marker[T * i] = 255;
            return marker[T * i + T] = 255;
          });
          marker2 = new Uint8Array(T);
          marker2[idxS - range] = 255;
          marker2[idxS + range] = 255;
          ref1 = Signal.Statictics.findMax(_S), _ = ref1[0], _idxS = ref1[1];
          marker3 = new Uint8Array(range * 2);
          marker3[_idxS] = 255;
          coms = [
            [section, true, true], [correl, true, true], [marker, true, true], [correls[0], true, true], [correls[1], true, true], [S, true, true], [marker2, true, true], [_S, true, true], [
              _S.map(function(v) {
                return v * v;
              }), true, true
            ], [
              _lowpass(_S.map(function(v) {
                return v * v;
              }), actx.sampleRate, 1000, 1), true, true
            ], [marker3, true, true]
          ].forEach(function(com, i) {
            var render;
            render = new Signal.Render(VIEW_SIZE, 64);
            Signal.Render.prototype.drawSignal.apply(render, com);
            _frame.add(render.element);
            return _frame.add(document.createElement("br"));
          });
          return {
            id: _id,
            max_offset: max_offset,
            pulseTime: pulseTime
          };
        });
        return {
          id: id,
          alias: alias,
          results: _results
        };
      });
      console.timeEnd("calcCorrel");
      console.info("calcRelDist");
      console.time("calcRelDist");
      sampleRates = datas.reduce((function(o, arg) {
        var id, sampleRate;
        id = arg.id, sampleRate = arg.sampleRate;
        o[id] = sampleRate;
        return o;
      }), {});
      pulseTimes = {};
      relDelayTimes = {};
      delayTimes = {};
      distances = {};
      distancesAliased = {};
      results.forEach(function(arg) {
        var alias, id, results;
        id = arg.id, alias = arg.alias, results = arg.results;
        return results.forEach(function(arg1) {
          var _id, correl, max_offset, max_score, pulseTime, results, section, stdev, stdscore;
          _id = arg1.id, section = arg1.section, results = arg1.results, correl = arg1.correl, max_score = arg1.max_score, max_offset = arg1.max_offset, stdev = arg1.stdev, stdscore = arg1.stdscore, pulseTime = arg1.pulseTime;
          pulseTimes[id] = pulseTimes[id] || {};
          return pulseTimes[id][_id] = pulseTime;
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          relDelayTimes[id1] = relDelayTimes[id1] || {};
          return relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          delayTimes[id1] = delayTimes[id1] || {};
          delayTimes[id1][id2] = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
          distances[id1] = distances[id1] || {};
          distances[id1][id2] = delayTimes[id1][id2] / 2 * SOUND_OF_SPEED;
          distancesAliased[aliases[id1]] = distancesAliased[aliases[id1]] || {};
          return distancesAliased[aliases[id1]][aliases[id2]] = distances[id1][id2];
        });
      });
      console.timeEnd("calcRelDist");
      console.info("distancesAliased", distancesAliased);
      console.info("calcRelPos");
      console.time("calcRelPos");
      ds = Object.keys(delayTimes).map(function(id1) {
        return Object.keys(delayTimes).map(function(id2) {
          return distances[id1][id2];
        });
      });
      pseudoPts = results.map(function(id1, i) {
        return new Point(Math.random() * 10, Math.random() * 10);
      });
      sdm = new SDM(pseudoPts, ds);
      K = 0;
      while (K++ < 200) {
        sdm.step();
      }
      console.timeEnd("calcRelPos");
      console.info("calcRelPos", sdm.det(), sdm.points);
      render = new Signal.Render(Math.pow(2, 8), Math.pow(2, 8));
      basePt = sdm.points[0];
      sdm.points.forEach(function(pt) {
        return render.cross(render.cnv.width / 2 + (pt.x - basePt.x) * 10, render.cnv.height / 2 + (pt.y - basePt.y) * 10, 16);
      });
      document.body.appendChild(render.element);
      document.body.style.backgroundColor = "lime";
      return next();
    };
  };

  _prepareRec = function(next) {
    var left, right;
    left = function(err) {
      throw err;
    };
    right = function(stream) {
      var source;
      source = actx.createMediaStreamSource(stream);
      if (location.hash.slice(1) === "red") {
        source.connect(analyser);
      }
      source.connect(processor);
      processor.connect(actx.destination);
      processor.addEventListener("audioprocess", function(ev) {
        if (isRecording) {
          return recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
        }
      });
      return next();
    };
    return navigator.getUserMedia({
      video: false,
      audio: true
    }, right, left);
  };

  _prepareSpect = function(next) {
    var i, render, rndr, spectrums;
    if (location.hash.slice(1) !== "red") {
      return next();
    }
    spectrums = (function() {
      var j, ref, results1;
      results1 = [];
      for (i = j = 0, ref = analyser.frequencyBinCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results1.push(new Uint8Array(analyser.frequencyBinCount));
      }
      return results1;
    })();
    rndr = new Signal.Render(spectrums.length, spectrums[0].length);
    document.body.appendChild(rndr.element);
    (render = function() {
      var spectrum;
      spectrum = spectrums.shift();
      analyser.getByteFrequencyData(spectrum);
      spectrums.push(spectrum);
      rndr.drawSpectrogram(spectrums);
      return requestAnimationFrame(render);
    })();
    return next();
  };

  _craetePictureFrame = function(description) {
    var fieldset, legend, style;
    fieldset = document.createElement('fieldset');
    style = document.createElement('style');
    style.appendChild(document.createTextNode("canvas,img{border:1px solid black;}"));
    style.setAttribute("scoped", "scoped");
    fieldset.appendChild(style);
    legend = document.createElement('legend');
    legend.appendChild(document.createTextNode(description));
    fieldset.appendChild(legend);
    fieldset.style.display = 'inline-block';
    fieldset.style.backgroundColor = "#D2E0E6";
    return {
      element: fieldset,
      add: function(element) {
        var p, txtNode;
        if (typeof element === "string") {
          txtNode = document.createTextNode(element);
          p = document.createElement("p");
          p.appendChild(txtNode);
          return fieldset.appendChild(p);
        } else {
          return fieldset.appendChild(element);
        }
      }
    };
  };

  _lowpass = function(input, sampleRate, freq, q) {

    /*
    // float input[]  …入力信号の格納されたバッファ。
    // flaot output[] …フィルタ処理した値を書き出す出力信号のバッファ。
    // int   size     …入力信号・出力信号のバッファのサイズ。
    // float sampleRate … サンプリング周波数。
    // float freq … カットオフ周波数。
    // float q    … フィルタのQ値。
     */
    var a0, a1, a2, alpha, b0, b1, b2, i, in1, in2, j, omega, out1, out2, output, ref, size;
    size = input.length;
    output = new Float32Array(size);
    omega = 2.0 * Math.PI * freq / sampleRate;
    alpha = Math.sin(omega) / (2.0 * q);
    a0 = 1.0 + alpha;
    a1 = -2.0 * Math.cos(omega);
    a2 = 1.0 - alpha;
    b0 = (1.0 - Math.cos(omega)) / 2.0;
    b1 = 1.0 - Math.cos(omega);
    b2 = (1.0 - Math.cos(omega)) / 2.0;
    in1 = 0.0;
    in2 = 0.0;
    out1 = 0.0;
    out2 = 0.0;
    for (i = j = 0, ref = size; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      output[i] = b0 / a0 * input[i] + b1 / a0 * in1 + b2 / a0 * in2 - a1 / a0 * out1 - a2 / a0 * out2;
      in2 = in1;
      in1 = input[i];
      out2 = out1;
      out1 = output[i];
    }
    return output;
  };

  window.addEventListener("DOMContentLoaded", function() {
    return _prepareRec(function() {
      return _prepareSpect(function() {
        return main();
      });
    });
  });

}).call(this);
