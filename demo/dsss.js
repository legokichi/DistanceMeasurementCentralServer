// Generated by CoffeeScript 1.10.0
(function() {
  var DSSS_SPEC, MULTIPASS_DISTANCE, SOUND_OF_SPEED, TEST_INPUT_MYSELF, VIEW_SIZE, _craetePictureFrame, _low_section_matched_ranges, _lowpass, _prepareRec, _prepareSpect, actx, analyser, beepPulse, changeColor, collect, isBroadcasting, isRecording, main, osc, play, processor, pulseStartTime, pulseStopTime, ready, recbuf, sendRec, socket, startPulse, startRec, stopPulse, stopRec;

  window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;

  changeColor = function() {
    return document.body.style.backgroundColor = location.hash.slice(1);
  };

  window.addEventListener("DOMContentLoaded", changeColor);

  window.addEventListener("hashchange", changeColor);

  window["socket"] = socket = io(location.hostname + ":" + location.port);

  socket.on("connect", console.info.bind(console, "connect"));

  socket.on("reconnect", console.info.bind(console, "reconnect"));

  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

  socket.on("reconnecting", console.info.bind(console, "reconnecting"));

  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

  socket.on("disconnect", console.info.bind(console, "disconnect"));

  socket.on("error", console.info.bind(console, "error"));

  socket.on("echo", console.info.bind(console, "echo"));

  socket.on("connect", function() {
    return socket.emit("echo", "hello");
  });

  window.onerror = function(err) {
    var pre, textnode;
    console.error(err, err != null ? err.stack : void 0);
    document.body.style.backgroundColor = "gray";
    pre = document.createElement("pre");
    textnode = document.createTextNode(err.stack || err);
    pre.appendChild(textnode);
    return document.body.appendChild(pre);
  };

  VIEW_SIZE = Math.pow(2, 12);

  actx = new AudioContext();

  osc = new OSC(actx);

  analyser = actx.createAnalyser();

  analyser.smoothingTimeConstant = 0;

  analyser.fftSize = 512;

  processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

  MULTIPASS_DISTANCE = 5;

  SOUND_OF_SPEED = 340;

  TEST_INPUT_MYSELF = false;

  _low_section_matched_ranges = {};

  recbuf = null;

  isRecording = false;

  isBroadcasting = false;

  pulseStartTime = {};

  pulseStopTime = {};

  DSSS_SPEC = null;

  main = function() {
    socket.on("ready", function(a) {
      return ready(a)(function() {
        return socket.emit("ready");
      });
    });
    socket.on("startRec", function() {
      return startRec(function() {
        return socket.emit("startRec");
      });
    });
    socket.on("startPulse", function(a) {
      return startPulse(a)(function() {
        return socket.emit("startPulse");
      });
    });
    socket.on("beepPulse", function() {
      return beepPulse(function() {
        return socket.emit("beepPulse");
      });
    });
    socket.on("stopPulse", function(a) {
      return stopPulse(a)(function() {
        return socket.emit("stopPulse");
      });
    });
    socket.on("stopRec", function() {
      return stopRec(function() {
        return socket.emit("stopRec");
      });
    });
    socket.on("sendRec", function() {
      return sendRec(function(a) {
        return socket.emit("sendRec", a);
      });
    });
    socket.on("collect", function(a) {
      return collect(a)(function(a) {
        return socket.emit("collect", a);
      });
    });
    return socket.on("play", function(a) {
      return play(a)(function() {
        return socket.emit("play");
      });
    });
  };

  ready = function(arg) {
    var PULSE_N, carrier_freq, isChirp, length, powL, seed;
    length = arg.length, seed = arg.seed, carrier_freq = arg.carrier_freq, isChirp = arg.isChirp, powL = arg.powL, PULSE_N = arg.PULSE_N;
    return function(next) {
      var abuf, matched, n, ss_code, ss_sig;
      n = function(a) {
        return a.split("").map(Number);
      };
      document.body.style.backgroundColor = location.hash.slice(1);
      recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);
      isRecording = false;
      isBroadcasting = false;
      pulseStartTime = {};
      pulseStopTime = {};
      DSSS_SPEC = null;
      ss_code = Signal.mseqGen(length, seed);
      matched = Signal.BPSK(ss_code, carrier_freq, actx.sampleRate, 0);
      ss_sig = matched;
      abuf = osc.createAudioBufferFromArrayBuffer(ss_sig, actx.sampleRate);
      DSSS_SPEC = {
        abuf: abuf,
        length: length,
        seed: seed,
        carrier_freq: carrier_freq,
        isChirp: isChirp,
        powL: powL,
        PULSE_N: PULSE_N
      };
      console.log(matched.length, ss_sig.length, abuf);
      (function() {
        var coms, corr;
        corr = Signal.fft_smart_overwrap_correlation(ss_sig, matched);
        return coms = [[matched, true, true], [ss_sig, true, true], [corr, true, true]].forEach(function(com, i) {
          var render;
          render = new Signal.Render(com[0].length / 100, 64);
          Signal.Render.prototype.drawSignal.apply(render, com);
          document.body.appendChild(render.element);
          return document.body.appendChild(document.createElement("br"));
        });
      });
      return next();
    };
  };

  startRec = function(next) {
    isRecording = true;
    return next();
  };

  startPulse = function(id) {
    return function(next) {
      pulseStartTime[id] = actx.currentTime;
      return next();
    };
  };

  beepPulse = function(next) {
    var abuf, anode, recur, startTime;
    abuf = DSSS_SPEC.abuf;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    if (TEST_INPUT_MYSELF) {
      anode.connect(processor);
      anode.connect(analyser);
    } else {
      anode.connect(actx.destination);
    }
    anode.start(actx.currentTime);
    startTime = actx.currentTime;
    return (recur = function() {
      if ((startTime + abuf.duration * 1.2) < actx.currentTime) {
        return next();
      } else {
        return setTimeout(recur, 100);
      }
    })();
  };

  stopPulse = function(id) {
    return function(next) {
      pulseStopTime[id] = actx.currentTime;
      return next();
    };
  };

  stopRec = function(next) {
    isRecording = false;
    return next();
  };

  sendRec = function(next) {
    var f32arr, o, recStartTime, recStopTime, startStops;
    f32arr = recbuf.merge();
    recStartTime = recbuf.sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
    recStopTime = recbuf.sampleTimes[recbuf.sampleTimes.length - 1];
    startStops = Object.keys(pulseStartTime).map(function(id) {
      var startPtr, stopPtr;
      startPtr = (pulseStartTime[id] - recStartTime) * recbuf.sampleRate;
      stopPtr = (pulseStopTime[id] - recStartTime + 1) * recbuf.sampleRate;
      return {
        id: id,
        startPtr: startPtr,
        stopPtr: stopPtr
      };
    });
    o = {
      id: socket.id,
      recStartTime: recStartTime,
      recStopTime: recStopTime,
      alias: location.hash.slice(1),
      startStops: startStops,
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      DSSS_SPEC: DSSS_SPEC
    };
    recbuf.clear();
    return next(o);
  };

  collect = function(datas) {
    return function(next) {
      var K, aliases, basePt, delayTimes, delayTimesAliased, distances, distancesAliased, ds, frame, pseudoPts, pulseTimes, pulseTimesAliased, recStartTimes, relDelayTimes, relDelayTimesAliased, render, results, sampleRates, sdm;
      if (location.hash.slice(1) !== "red") {
        return next();
      }
      frame = _craetePictureFrame("collect", document.body);
      aliases = datas.reduce((function(o, arg) {
        var alias, id;
        id = arg.id, alias = arg.alias;
        o[id] = alias;
        return o;
      }), {});
      results = datas.map(function(arg) {
        var DSSS_SPEC, PULSE_N, _frame, _results, alias, carrier_freq, id, isChirp, length, matched, powL, recF32arr, sampleRate, seed, ss_code, startStops;
        id = arg.id, alias = arg.alias, startStops = arg.startStops, recF32arr = arg.recF32arr, DSSS_SPEC = arg.DSSS_SPEC, sampleRate = arg.sampleRate;
        length = DSSS_SPEC.length, seed = DSSS_SPEC.seed, carrier_freq = DSSS_SPEC.carrier_freq, isChirp = DSSS_SPEC.isChirp, powL = DSSS_SPEC.powL, PULSE_N = DSSS_SPEC.PULSE_N;
        _frame = _craetePictureFrame(alias + "@" + id);
        frame.add(_frame.element);
        ss_code = Signal.mseqGen(length, seed);
        matched = Signal.BPSK(ss_code, carrier_freq, actx.sampleRate, 0);
        recF32arr = new Float32Array(recF32arr);
        _results = startStops.map(function(arg1) {
          var T, __frame, _id, ave, begin, cutoff, end, flag, idx, j, len, low_section_matched_range, marker, max_offset, med, mse_section_matched_range, offset, pulseTime, range, ref, section, section_matched, section_matched_range, start, startPtr, stdscore_section_matched_range, stop, stopPtr, threshold, v, val, vari, zoom_ratio;
          _id = arg1.id, startPtr = arg1.startPtr, stopPtr = arg1.stopPtr;
          __frame = _craetePictureFrame(aliases[id] + "<->" + aliases[_id]);
          _frame.add(__frame.element);
          T = matched.length;
          section = recF32arr.subarray(startPtr, stopPtr);
          __frame.view(section, "section");
          section_matched = Signal.fft_smart_overwrap_correlation(section, matched);
          __frame.view(section_matched, "section * matched");
          __frame.text((ref = Signal.Statictics.findMax(section_matched), val = ref[0], idx = ref[1], ref));
          range = MULTIPASS_DISTANCE / SOUND_OF_SPEED * sampleRate | 0;
          begin = idx - range;
          if (begin < 0) {
            begin = 0;
          }
          end = idx + range;
          zoom_ratio = 50;
          start = idx - section_matched.length / zoom_ratio | 0;
          if (start < 0) {
            start = 0;
          }
          stop = idx + section_matched.length / zoom_ratio | 0;
          section_matched_range = section_matched.subarray(begin, end);
          __frame.view(section_matched_range, "section * matched, range" + MULTIPASS_DISTANCE);
          mse_section_matched_range = section_matched_range.map(function(a) {
            return a * a;
          });
          cutoff = 1000;
          low_section_matched_range = _lowpass(mse_section_matched_range, actx.sampleRate, cutoff, 1);
          __frame.view(low_section_matched_range, "section * matched, lowpass" + cutoff);
          vari = Signal.Statictics.variance(low_section_matched_range);
          ave = Signal.Statictics.average(low_section_matched_range);
          med = Signal.Statictics.median(low_section_matched_range);
          threshold = 80;
          stdscore_section_matched_range = low_section_matched_range.map(function(x) {
            return 10 * (x - ave) / vari + 50;
          });
          flag = true;
          while (flag) {
            for (offset = j = 0, len = stdscore_section_matched_range.length; j < len; offset = ++j) {
              v = stdscore_section_matched_range[offset];
              if (threshold < v && med < v && ave < v) {
                flag = false;
                break;
              }
            }
            threshold -= 1;
          }
          marker = new Uint8Array(low_section_matched_range.length);
          marker[offset] = 255;
          __frame.view(marker, "offset" + offset);
          max_offset = begin + offset;
          pulseTime = (startPtr + max_offset) / sampleRate;
          _low_section_matched_ranges[id] = _low_section_matched_ranges[id] || {};
          _low_section_matched_ranges[id][_id] = _low_section_matched_ranges[id][_id] || new Float32Array(low_section_matched_range.length);
          _low_section_matched_ranges[id][_id].forEach(function(_, i) {
            return _low_section_matched_ranges[id][_id][i] += low_section_matched_range[i];
          });
          __frame.view(_low_section_matched_ranges[id][_id], "_low_section_matched_ranges[" + id + "][" + _id + "]");
          return {
            id: _id,
            max_offset: max_offset,
            pulseTime: pulseTime
          };
        });
        return {
          id: id,
          alias: alias,
          results: _results
        };
      });
      sampleRates = datas.reduce((function(o, arg) {
        var id, sampleRate;
        id = arg.id, sampleRate = arg.sampleRate;
        o[id] = sampleRate;
        return o;
      }), {});
      recStartTimes = datas.reduce((function(o, arg) {
        var id, recStartTime;
        id = arg.id, recStartTime = arg.recStartTime;
        o[id] = recStartTime;
        return o;
      }), {});
      pulseTimes = {};
      relDelayTimes = {};
      delayTimes = {};
      distances = {};
      relDelayTimesAliased = {};
      distancesAliased = {};
      delayTimesAliased = {};
      pulseTimesAliased = {};
      results.forEach(function(arg) {
        var alias, id, results;
        id = arg.id, alias = arg.alias, results = arg.results;
        return results.forEach(function(arg1) {
          var _id, max_offset, pulseTime;
          _id = arg1.id, max_offset = arg1.max_offset, pulseTime = arg1.pulseTime;
          pulseTimes[id] = pulseTimes[id] || {};
          pulseTimes[id][_id] = pulseTime;
          pulseTimesAliased[aliases[id]] = pulseTimesAliased[aliases[id]] || {};
          return pulseTimesAliased[aliases[id]][aliases[_id]] = pulseTimes[id][_id];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          relDelayTimes[id1] = relDelayTimes[id1] || {};
          relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
          relDelayTimesAliased[aliases[id1]] = relDelayTimesAliased[aliases[id1]] || {};
          return relDelayTimesAliased[aliases[id1]][aliases[id2]] = relDelayTimes[id1][id2];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          delayTimes[id1] = delayTimes[id1] || {};
          delayTimes[id1][id2] = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
          delayTimesAliased[aliases[id1]] = delayTimesAliased[aliases[id1]] || {};
          delayTimesAliased[aliases[id1]][aliases[id2]] = delayTimes[id1][id2];
          distances[id1] = distances[id1] || {};
          distances[id1][id2] = delayTimes[id1][id2] / 2 * SOUND_OF_SPEED;
          distancesAliased[aliases[id1]] = distancesAliased[aliases[id1]] || {};
          return distancesAliased[aliases[id1]][aliases[id2]] = distances[id1][id2];
        });
      });
      if (console.table != null) {
        console.group("table");
        console.info("recStartTimes", recStartTimes);
        console.info("pulseTimesAliased");
        console.table(pulseTimesAliased);
        console.info("relDelayTimesAliased");
        console.table(relDelayTimesAliased);
        console.info("delayTimesAliased");
        console.table(delayTimesAliased);
        console.info("distancesAliased");
        console.table(distancesAliased);
        console.groupEnd();
      }
      ds = Object.keys(delayTimes).map(function(id1) {
        return Object.keys(delayTimes).map(function(id2) {
          return distances[id1][id2];
        });
      });
      pseudoPts = results.map(function(id1, i) {
        return new Point(Math.random() * 10, Math.random() * 10);
      });
      sdm = new SDM(pseudoPts, ds);
      K = 0;
      while (K++ < 200) {
        sdm.step();
      }
      render = new Signal.Render(Math.pow(2, 8), Math.pow(2, 8));
      basePt = sdm.points[0];
      sdm.points.forEach(function(pt) {
        return render.cross(render.cnv.width / 2 + (pt.x - basePt.x) * 10, render.cnv.height / 2 + (pt.y - basePt.y) * 10, 16);
      });
      document.body.appendChild(render.element);
      document.body.style.backgroundColor = "lime";
      return next({
        pulseTimes: pulseTimes,
        delayTimes: delayTimes,
        aliases: aliases,
        currentTime: actx.currentTime,
        recStartTimes: recStartTimes
      });
    };
  };

  play = function(data) {
    return function(next) {
      var abuf, currentTime, delayTimes, id, matched, now, now2, offsetTime, pulseTimes, recStartTimes, wait;
      console.log(data);
      wait = data.wait, pulseTimes = data.pulseTimes, delayTimes = data.delayTimes, id = data.id, currentTime = data.currentTime, recStartTimes = data.recStartTimes, now = data.now, now2 = data.now2;
      console.log(actx.currentTime);
      console.log(offsetTime = recStartTimes[socket.id] + (pulseTimes[socket.id][id] - delayTimes[socket.id][id]) + (currentTime - (pulseTimes[id][id] + recStartTimes[id])) + (now2 - now) / 1000 + wait + 3);
      matched = Signal.BPSK([1], 2000, actx.sampleRate, 0, actx.sampleRate * 1);
      abuf = osc.createAudioBufferFromArrayBuffer(matched, actx.sampleRate);
      setTimeout((function() {
        var node;
        node = osc.createAudioNodeFromAudioBuffer(abuf);
        node.start(offsetTime + 1);
        node.loop = false;
        node.connect(actx.destination);
        return next();
      }), 2000);
      return function() {
        return osc.createAudioBufferFromURL("./TellYourWorld1min.mp3").then(function(abuf) {
          var node;
          node = osc.createAudioNodeFromAudioBuffer(abuf);
          node.start(offsetTime);
          node.loop = true;
          node.connect(actx.destination);
          return next();
        });
      };
    };
  };

  _prepareRec = function(next) {
    var left, right;
    left = function(err) {
      throw err;
    };
    right = function(stream) {
      var prev, source;
      source = actx.createMediaStreamSource(stream);
      if (!TEST_INPUT_MYSELF) {
        source.connect(processor);
        source.connect(analyser);
      }
      processor.connect(actx.destination);
      prev = false;
      processor.addEventListener("audioprocess", function(ev) {
        if (isRecording || prev) {
          recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
        }
        return prev = isRecording;
      });
      return next();
    };
    return navigator.getUserMedia({
      video: false,
      audio: true
    }, right, left);
  };

  _prepareSpect = function(next) {
    var i, render, rndr, spectrums;
    return next();
    if (location.hash.slice(1) !== "red") {
      return next();
    }
    spectrums = (function() {
      var j, ref, results1;
      results1 = [];
      for (i = j = 0, ref = analyser.frequencyBinCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        results1.push(new Uint8Array(analyser.frequencyBinCount));
      }
      return results1;
    })();
    rndr = new Signal.Render(spectrums.length, spectrums[0].length);
    document.body.appendChild(rndr.element);
    (render = function() {
      var spectrum;
      spectrum = spectrums.shift();
      analyser.getByteFrequencyData(spectrum);
      spectrums.push(spectrum);
      rndr.drawSpectrogram(spectrums);
      return requestAnimationFrame(render);
    })();
    return next();
  };

  _craetePictureFrame = function(description, target) {
    var fieldset, legend, style;
    fieldset = document.createElement('fieldset');
    style = document.createElement('style');
    style.appendChild(document.createTextNode("canvas,img{border:1px solid black;}"));
    style.setAttribute("scoped", "scoped");
    fieldset.appendChild(style);
    legend = document.createElement('legend');
    legend.appendChild(document.createTextNode(description));
    fieldset.appendChild(legend);
    fieldset.style.display = 'inline-block';
    fieldset.style.backgroundColor = "#D2E0E6";
    if (target != null) {
      target.appendChild(fieldset);
    }
    return {
      element: fieldset,
      add: function(element) {
        var p, txtNode;
        if (typeof element === "string") {
          txtNode = document.createTextNode(element);
          p = document.createElement("p");
          p.appendChild(txtNode);
          return fieldset.appendChild(p);
        } else {
          return fieldset.appendChild(element);
        }
      },
      view: function(arr, title) {
        var __frame, render, width;
        __frame = _craetePictureFrame(title + ("(" + arr.length + ")"));
        width = VIEW_SIZE < arr.length ? VIEW_SIZE : arr.length;
        render = new Signal.Render(width, 64);
        Signal.Render.prototype.drawSignal.apply(render, [arr, true, true]);
        __frame.add(render.element);
        this.add(__frame.element);
        return this.add(document.createElement("br"));
      },
      text: function(title) {
        this.add(document.createTextNode(title));
        return this.add(document.createElement("br"));
      }
    };
  };

  _lowpass = function(input, sampleRate, freq, q) {

    /*
    // float input[]  …入力信号の格納されたバッファ。
    // flaot output[] …フィルタ処理した値を書き出す出力信号のバッファ。
    // int   size     …入力信号・出力信号のバッファのサイズ。
    // float sampleRate … サンプリング周波数。
    // float freq … カットオフ周波数。
    // float q    … フィルタのQ値。
     */
    var a0, a1, a2, alpha, b0, b1, b2, i, in1, in2, j, omega, out1, out2, output, ref, size;
    size = input.length;
    output = new Float32Array(size);
    omega = 2.0 * Math.PI * freq / sampleRate;
    alpha = Math.sin(omega) / (2.0 * q);
    a0 = 1.0 + alpha;
    a1 = -2.0 * Math.cos(omega);
    a2 = 1.0 - alpha;
    b0 = (1.0 - Math.cos(omega)) / 2.0;
    b1 = 1.0 - Math.cos(omega);
    b2 = (1.0 - Math.cos(omega)) / 2.0;
    in1 = 0.0;
    in2 = 0.0;
    out1 = 0.0;
    out2 = 0.0;
    for (i = j = 0, ref = size; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      output[i] = b0 / a0 * input[i] + b1 / a0 * in1 + b2 / a0 * in2 - a1 / a0 * out1 - a2 / a0 * out2;
      in2 = in1;
      in1 = input[i];
      out2 = out1;
      out1 = output[i];
    }
    return output;
  };

  window.addEventListener("DOMContentLoaded", function() {
    return _prepareRec(function() {
      return _prepareSpect(function() {
        return main();
      });
    });
  });

}).call(this);
