// Generated by CoffeeScript 1.10.0
var CARRIER_FREQ, ENCODED_DATA, MATCHED, MODULATED_PULSE, MSEQ_KEY, SS_CODE, VIEW_SIZE, _flipProc, _prepareRec, _prepareSpect, abuf, actx, analyser, changeColor, isBroadcasting, isRecording, main, osc, processor, pulseStartTime, pulseStopTime, recbuf, socket;

window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;

changeColor = function() {
  return document.body.style.backgroundColor = location.hash.slice(1);
};

window.addEventListener("DOMContentLoaded", changeColor);

window.addEventListener("hashchange", changeColor);

window["socket"] = socket = io(location.hostname + ":" + location.port);

socket.on("connect", console.info.bind(console, "connect"));

socket.on("reconnect", console.info.bind(console, "reconnect"));

socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

socket.on("reconnecting", console.info.bind(console, "reconnecting"));

socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

socket.on("disconnect", console.info.bind(console, "disconnect"));

socket.on("error", console.info.bind(console, "error"));

socket.on("echo", console.info.bind(console, "echo"));

socket.on("connect", function() {
  return socket.emit("echo", "hello");
});

window.onerror = function(err) {
  var pre, textnode;
  console.error(err);
  document.body.style.backgroundColor = "gray";
  pre = document.createElement("pre");
  textnode = document.createTextNode(err.stack || err);
  pre.appendChild(textnode);
  return document.body.appendChild(pre);
};

actx = new AudioContext();

osc = new OSC(actx);

analyser = actx.createAnalyser();

analyser.smoothingTimeConstant = 0;

analyser.fftSize = 512;

processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);

isRecording = false;

isBroadcasting = false;

pulseStartTime = {};

pulseStopTime = {};

CARRIER_FREQ = 4410;

MSEQ_KEY = [15, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]];

SS_CODE = Signal.mseqGen(MSEQ_KEY[0], MSEQ_KEY[1]);

console.log(SS_CODE.length);

ENCODED_DATA = Signal.encode_chipcode([1], SS_CODE);

MATCHED = Signal.BPSK(SS_CODE, CARRIER_FREQ, actx.sampleRate, 0);

console.log(MATCHED.length);

MODULATED_PULSE = Signal.BPSK(ENCODED_DATA, CARRIER_FREQ, actx.sampleRate, 0, ENCODED_DATA.length * (1 / CARRIER_FREQ) * actx.sampleRate);

console.log(ENCODED_DATA.length);

console.log(abuf = osc.createAudioBufferFromArrayBuffer(MODULATED_PULSE, actx.sampleRate));

VIEW_SIZE = Math.pow(2, 12);

main = function() {
  var beepPulse, ready, sendRec, startPulse, startRec, stopPulse, stopRec;
  (function() {
    var correl, render;
    correl = Signal.fft_smart_overwrap_correlation(ENCODED_DATA, SS_CODE);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(ENCODED_DATA, true, true);
    document.body.appendChild(render.element);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(correl, true, true);
    document.body.appendChild(render.element);
    correl = Signal.fft_smart_overwrap_correlation(MODULATED_PULSE, MATCHED);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(MODULATED_PULSE, true, true);
    document.body.appendChild(render.element);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(correl, true, true);
    return document.body.appendChild(render.element);
  })();
  socket.on("ready", function() {
    return ready(function() {
      return socket.emit("ready");
    });
  });
  socket.on("startRec", function() {
    return startRec(function() {
      return socket.emit("startRec");
    });
  });
  socket.on("startPulse", function(a) {
    return startPulse(a)(function() {
      return socket.emit("startPulse");
    });
  });
  socket.on("beepPulse", function() {
    return beepPulse(function() {
      return socket.emit("beepPulse");
    });
  });
  socket.on("stopPulse", function(a) {
    return stopPulse(a)(function() {
      return socket.emit("stopPulse");
    });
  });
  socket.on("stopRec", function() {
    return stopRec(function() {
      return socket.emit("stopRec");
    });
  });
  socket.on("sendRec", function() {
    return sendRec(function(a) {
      return socket.emit("sendRec", a);
    });
  });
  ready = function(next) {
    return next();
  };
  startRec = _flipProc(function() {
    return isRecording = true;
  });
  startPulse = function(id) {
    return _flipProc(function() {
      return pulseStartTime[id] = actx.currentTime;
    });
  };
  beepPulse = function(next) {
    var anode, recur;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    anode.connect(actx.destination);
    anode.start(actx.currentTime);
    return setTimeout((recur = function() {
      if (recbuf.chsBuffers[0].length > Math.ceil(MODULATED_PULSE.length / processor.bufferSize)) {
        return next();
      } else {
        return setTimeout(recur, 1);
      }
    }), MODULATED_PULSE.length / actx.sampleRate * 1000);
  };
  stopPulse = function(id) {
    return _flipProc(function() {
      return pulseStopTime[id] = actx.currentTime;
    });
  };
  stopRec = _flipProc(function() {
    return isRecording = false;
  });
  return sendRec = function(next) {
    var f32arr, o;
    f32arr = recbuf.merge();
    Object.keys(pulseStartTime).forEach(function(id) {
      var correl, max_offset, max_score, recStartTime, recStopTime, ref, section, startPtr, stopPtr;
      recStartTime = recbuf.sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
      recStopTime = recbuf.sampleTimes[recbuf.sampleTimes.length - 1];
      startPtr = (pulseStartTime[id] - recStartTime) * recbuf.sampleRate;
      stopPtr = (pulseStopTime[id] - recStartTime) * recbuf.sampleRate;
      section = f32arr.subarray(startPtr, stopPtr);
      correl = Signal.fft_smart_overwrap_correlation(section, MATCHED);
      console.log((ref = Signal.Statictics.findMax(correl), max_score = ref[0], max_offset = ref[1], ref));
      console.log(Signal.Statictics.stdev(correl));
      console.log(Signal.Statictics.stdscore(correl, max_score));
      return (function() {
        var offset_arr, render;
        document.body.appendChild(document.createTextNode(id + "@" + socket.id + location.hash));
        render = new Signal.Render(VIEW_SIZE, 127);
        render.drawSignal(section, true, true);
        document.body.appendChild(render.element);
        render = new Signal.Render(VIEW_SIZE, 127);
        render.drawSignal(correl, true, true);
        document.body.appendChild(render.element);
        render = new Signal.Render(VIEW_SIZE, 12);
        offset_arr = new Uint8Array(correl.length);
        offset_arr[max_offset] = 255;
        render.ctx.strokeStyle = "red";
        render.drawSignal(offset_arr, true, true);
        return document.body.appendChild(render.element);
      })();
    });
    o = {
      id: socket.id,
      alias: location.hash.slice(1),
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      recF32arrLen: f32arr.length,
      MATCHEDarr: MATCHED.buffer,
      MATCHEDLen: MATCHED.length,
      MSEQ_KEY: MSEQ_KEY
    };
    recbuf.clear();
    return next(o);
  };
};

_prepareRec = function(next) {
  var left, right;
  left = function(err) {
    throw err;
  };
  right = function(stream) {
    var source;
    source = actx.createMediaStreamSource(stream);
    source.connect(analyser);
    source.connect(processor);
    processor.connect(actx.destination);
    processor.addEventListener("audioprocess", function(ev) {
      if (isRecording) {
        return recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
      }
    });
    return next();
  };
  return navigator.getUserMedia({
    video: false,
    audio: true
  }, right, left);
};

_prepareSpect = function(next) {
  var i, render, rndr, spectrums, targetIndex;
  targetIndex = (CARRIER_FREQ * analyser.fftSize) / actx.sampleRate | 0;
  spectrums = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 0, ref = analyser.frequencyBinCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      results.push(new Uint8Array(analyser.frequencyBinCount));
    }
    return results;
  })();
  rndr = new Signal.Render(spectrums.length, spectrums[0].length);
  document.body.appendChild(rndr.element);
  (render = function() {
    var spectrum;
    spectrum = spectrums.shift();
    analyser.getByteFrequencyData(spectrum);
    spectrums.push(spectrum);
    rndr.drawSpectrogram(spectrums);
    return requestAnimationFrame(render);
  })();
  return next();
};

_flipProc = function(next) {
  return function(proc) {
    proc();
    return next();
  };
};

window.addEventListener("DOMContentLoaded", function() {
  return _prepareRec(function() {
    return _prepareSpect(function() {
      return main();
    });
  });
});
