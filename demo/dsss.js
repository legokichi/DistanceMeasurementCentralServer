// Generated by CoffeeScript 1.10.0
var CARRIER_FREQ, ENCODED_DATA, MATCHED, MODULATED_PULSE, MSEQ_KEY, SS_CODE, VIEW_SIZE, _flipProc, _prepareRec, _prepareSpect, abuf, actx, analyser, changeColor, isBroadcasting, isRecording, main, osc, processor, pulseStartTime, pulseStopTime, recbuf, socket;

window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;

changeColor = function() {
  return document.body.style.backgroundColor = location.hash.slice(1);
};

window.addEventListener("DOMContentLoaded", changeColor);

window.addEventListener("hashchange", changeColor);

window["socket"] = socket = io(location.hostname + ":" + location.port);

socket.on("connect", console.info.bind(console, "connect"));

socket.on("reconnect", console.info.bind(console, "reconnect"));

socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

socket.on("reconnecting", console.info.bind(console, "reconnecting"));

socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

socket.on("disconnect", console.info.bind(console, "disconnect"));

socket.on("error", console.info.bind(console, "error"));

socket.on("echo", console.info.bind(console, "echo"));

socket.on("connect", function() {
  return socket.emit("echo", "hello");
});

window.onerror = function(err) {
  var pre, textnode;
  console.error(err);
  document.body.style.backgroundColor = "gray";
  pre = document.createElement("pre");
  textnode = document.createTextNode(err.stack || err);
  pre.appendChild(textnode);
  return document.body.appendChild(pre);
};

actx = new AudioContext();

osc = new OSC(actx);

analyser = actx.createAnalyser();

analyser.smoothingTimeConstant = 0;

analyser.fftSize = 512;

processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);

isRecording = false;

isBroadcasting = false;

pulseStartTime = {};

pulseStopTime = {};

CARRIER_FREQ = 4410 / 2;

MSEQ_KEY = [12, [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1]];

SS_CODE = Signal.mseqGen(MSEQ_KEY[0], MSEQ_KEY[1]);

ENCODED_DATA = Signal.encode_chipcode([1], SS_CODE);

MATCHED = Signal.BPSK(SS_CODE, CARRIER_FREQ, actx.sampleRate, 0);

MODULATED_PULSE = Signal.BPSK(ENCODED_DATA, CARRIER_FREQ, actx.sampleRate, 0, ENCODED_DATA.length * (1 / CARRIER_FREQ) * actx.sampleRate);

console.log(abuf = osc.createAudioBufferFromArrayBuffer(MODULATED_PULSE, actx.sampleRate));

VIEW_SIZE = Math.pow(2, 10);

main = function() {
  var beepPulse, collect, notdo, ready, sendRec, startPulse, startRec, stopPulse, stopRec;
  notdo = function() {
    var correl, render;
    correl = Signal.fft_smart_overwrap_correlation(ENCODED_DATA, SS_CODE);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(ENCODED_DATA, true, true);
    document.body.appendChild(render.element);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(correl, true, true);
    document.body.appendChild(render.element);
    correl = Signal.fft_smart_overwrap_correlation(MODULATED_PULSE, MATCHED);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(MODULATED_PULSE, true, true);
    document.body.appendChild(render.element);
    render = new Signal.Render(VIEW_SIZE, 127);
    render.drawSignal(correl, true, true);
    return document.body.appendChild(render.element);
  };
  socket.on("ready", function() {
    return ready(function() {
      return socket.emit("ready");
    });
  });
  socket.on("startRec", function() {
    return startRec(function() {
      return socket.emit("startRec");
    });
  });
  socket.on("startPulse", function(a) {
    return startPulse(a)(function() {
      return socket.emit("startPulse");
    });
  });
  socket.on("beepPulse", function() {
    return beepPulse(function() {
      return socket.emit("beepPulse");
    });
  });
  socket.on("stopPulse", function(a) {
    return stopPulse(a)(function() {
      return socket.emit("stopPulse");
    });
  });
  socket.on("stopRec", function() {
    return stopRec(function() {
      return socket.emit("stopRec");
    });
  });
  socket.on("sendRec", function() {
    return sendRec(function(a) {
      return socket.emit("sendRec", a);
    });
  });
  socket.on("collect", function(a) {
    return collect(a)(function() {
      return socket.emit("collect");
    });
  });
  ready = function(next) {
    return next();
  };
  startRec = _flipProc(function() {
    return isRecording = true;
  });
  startPulse = function(id) {
    return _flipProc(function() {
      return pulseStartTime[id] = actx.currentTime;
    });
  };
  beepPulse = function(next) {
    var anode, recur;
    anode = osc.createAudioNodeFromAudioBuffer(abuf);
    anode.connect(actx.destination);
    anode.start(actx.currentTime);
    return setTimeout((recur = function() {
      if (recbuf.chsBuffers[0].length > Math.ceil(MODULATED_PULSE.length / processor.bufferSize)) {
        return next();
      } else {
        return setTimeout(recur, 1);
      }
    }), MODULATED_PULSE.length / actx.sampleRate * 1000);
  };
  stopPulse = function(id) {
    return _flipProc(function() {
      return pulseStopTime[id] = actx.currentTime;
    });
  };
  stopRec = _flipProc(function() {
    return isRecording = false;
  });
  sendRec = function(next) {
    var f32arr, o, recStartTime, recStopTime, startStops;
    f32arr = recbuf.merge();
    recStartTime = recbuf.sampleTimes[0] - (recbuf.bufferSize / recbuf.sampleRate);
    recStopTime = recbuf.sampleTimes[recbuf.sampleTimes.length - 1];
    startStops = Object.keys(pulseStartTime).map(function(id) {
      var startPtr, stopPtr;
      startPtr = (pulseStartTime[id] - recStartTime) * recbuf.sampleRate;
      stopPtr = (pulseStopTime[id] - recStartTime) * recbuf.sampleRate;
      return {
        id: id,
        startPtr: startPtr,
        stopPtr: stopPtr
      };
    });
    o = {
      id: socket.id,
      alias: location.hash.slice(1),
      startStops: startStops,
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      recF32arrLen: f32arr.length,
      MATCHEDarr: MATCHED.buffer,
      MATCHEDLen: MATCHED.length,
      MSEQ_KEY: MSEQ_KEY,
      SS_CODE: SS_CODE,
      CARRIER_FREQ: CARRIER_FREQ
    };
    recbuf.clear();
    return next(o);
  };
  return collect = function(datas) {
    return function(next) {
      var aliases, delayTimes, distances, distancesAliased, pulseTimes, relDelayTimes, results;
      if (location.hash.slice(1) !== "red") {
        return next();
      }
      console.log(datas);
      aliases = datas.reduce((function(o, arg) {
        var alias, id;
        id = arg.id, alias = arg.alias;
        o[id] = alias;
        return o;
      }), {});
      console.time("calc");
      results = datas.map(function(arg) {
        var MATCHEDarr, _results, alias, id, recF32arr, sampleRate, startStops;
        id = arg.id, alias = arg.alias, startStops = arg.startStops, recF32arr = arg.recF32arr, MATCHEDarr = arg.MATCHEDarr, sampleRate = arg.sampleRate;
        _results = startStops.map(function(arg1) {
          var _id, correl, max_offset, max_score, pulseTime, ref, section, startPtr, stdev, stdscore, stopPtr;
          _id = arg1.id, startPtr = arg1.startPtr, stopPtr = arg1.stopPtr;
          section = new Float32Array(recF32arr).subarray(startPtr, stopPtr);
          correl = Signal.fft_smart_overwrap_correlation(section, new Float32Array(MATCHEDarr));
          console.log(id, _id);
          console.log((ref = Signal.Statictics.findMax(correl), max_score = ref[0], max_offset = ref[1], ref));
          console.log(stdev = Signal.Statictics.stdev(correl));
          console.log(stdscore = Signal.Statictics.stdscore(correl, max_score));
          console.log(pulseTime = (startPtr + max_offset) / sampleRate);
          return {
            id: _id,
            section: section,
            correl: correl,
            max_score: max_score,
            max_offset: max_offset,
            stdev: stdev,
            stdscore: stdscore,
            pulseTime: pulseTime
          };
        });
        return {
          id: id,
          alias: alias,
          results: _results
        };
      });
      pulseTimes = {};
      relDelayTimes = {};
      delayTimes = {};
      distances = {};
      distancesAliased = {};
      results.forEach(function(arg) {
        var alias, id, results;
        id = arg.id, alias = arg.alias, results = arg.results;
        return results.forEach(function(arg1) {
          var _id, correl, max_offset, max_score, pulseTime, section, stdev, stdscore;
          _id = arg1.id, section = arg1.section, correl = arg1.correl, max_score = arg1.max_score, max_offset = arg1.max_offset, stdev = arg1.stdev, stdscore = arg1.stdscore, pulseTime = arg1.pulseTime;
          pulseTimes[id] = pulseTimes[id] || {};
          return pulseTimes[id][_id] = pulseTime;
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          relDelayTimes[id1] = relDelayTimes[id1] || {};
          return relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          delayTimes[id1] = delayTimes[id1] || {};
          delayTimes[id1][id2] = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
          distances[id1] = distances[id1] || {};
          distances[id1][id2] = delayTimes[id1][id2] / 2 * 340;
          distancesAliased[aliases[id1]] = distancesAliased[aliases[id1]] || {};
          return distancesAliased[aliases[id1]][aliases[id2]] = delayTimes[id1][id2] / 2 * 340;
        });
      });
      console.timeEnd("calc");
      console.info("distancesAliased", distancesAliased);
      setTimeout(function() {
        results.forEach(function(arg) {
          var alias, id, results;
          id = arg.id, alias = arg.alias, results = arg.results;
          return results.forEach(function(arg1) {
            var _id, correl, max_offset, max_score, offset_arr, pulseTime, render, section, stdev, stdscore, zoomarr;
            _id = arg1.id, section = arg1.section, correl = arg1.correl, max_score = arg1.max_score, max_offset = arg1.max_offset, stdev = arg1.stdev, stdscore = arg1.stdscore, pulseTime = arg1.pulseTime;
            document.body.appendChild(document.createTextNode(aliases[id] + "@" + aliases[_id] + "(" + id + "@" + _id + ")"));
            render = new Signal.Render(VIEW_SIZE, 127);
            render.drawSignal(section, true, true);
            document.body.appendChild(render.element);
            render = new Signal.Render(VIEW_SIZE, 127);
            render.drawSignal(correl, true, true);
            document.body.appendChild(render.element);
            render = new Signal.Render(VIEW_SIZE, 12);
            offset_arr = new Uint8Array(correl.length);
            offset_arr[max_offset - 256] = 255;
            offset_arr[max_offset] = 255;
            offset_arr[max_offset + 256] = 255;
            render.ctx.strokeStyle = "red";
            render.drawSignal(offset_arr, true, true);
            document.body.appendChild(render.element);
            zoomarr = correl.subarray(max_offset - 256, max_offset + 256);
            render = new Signal.Render(VIEW_SIZE, 127);
            render.drawSignal(zoomarr, true, true);
            document.body.appendChild(render.element);
            render = new Signal.Render(VIEW_SIZE, 12);
            offset_arr = new Uint8Array(zoomarr.length);
            offset_arr[256] = 255;
            render.ctx.strokeStyle = "red";
            render.drawSignal(offset_arr, true, true);
            return document.body.appendChild(render.element);
          });
        });
        return document.body.style.backgroundColor = "lime";
      });
      return next();
    };
  };
};

_prepareRec = function(next) {
  var left, right;
  left = function(err) {
    throw err;
  };
  right = function(stream) {
    var source;
    source = actx.createMediaStreamSource(stream);
    source.connect(processor);
    processor.connect(actx.destination);
    processor.addEventListener("audioprocess", function(ev) {
      if (isRecording) {
        return recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
      }
    });
    return next();
  };
  return navigator.getUserMedia({
    video: false,
    audio: true
  }, right, left);
};

_prepareSpect = function(next) {
  var donot, i, render, rndr, spectrums, targetIndex;
  targetIndex = (CARRIER_FREQ * analyser.fftSize) / actx.sampleRate | 0;
  spectrums = (function() {
    var j, ref, results1;
    results1 = [];
    for (i = j = 0, ref = analyser.frequencyBinCount; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      results1.push(new Uint8Array(analyser.frequencyBinCount));
    }
    return results1;
  })();
  rndr = new Signal.Render(spectrums.length, spectrums[0].length);
  donot = render = function() {
    var spectrum;
    spectrum = spectrums.shift();
    analyser.getByteFrequencyData(spectrum);
    spectrums.push(spectrum);
    rndr.drawSpectrogram(spectrums);
    return requestAnimationFrame(render);
  };
  return next();
};

_flipProc = function(next) {
  return function(proc) {
    proc();
    return next();
  };
};

window.addEventListener("DOMContentLoaded", function() {
  return _prepareRec(function() {
    return _prepareSpect(function() {
      return main();
    });
  });
});
