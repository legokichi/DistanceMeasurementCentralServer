// Generated by CoffeeScript 1.10.0
(function() {
  var MULTIPASS_DISTANCE, SOUND_OF_SPEED, VIEW_SIZE, _craetePictureFrame, calc, socket;

  window["socket"] = socket = io(location.hostname + ":" + location.port + "/calc");

  socket.on("connect", console.info.bind(console, "connect"));

  socket.on("reconnect", console.info.bind(console, "reconnect"));

  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));

  socket.on("reconnecting", console.info.bind(console, "reconnecting"));

  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));

  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));

  socket.on("disconnect", console.info.bind(console, "disconnect"));

  socket.on("error", console.info.bind(console, "error"));

  MULTIPASS_DISTANCE = 8;

  SOUND_OF_SPEED = 340;

  socket.on("calc", function(a) {
    return calc(a)(function(a) {
      return socket.emit("calc", a);
    });
  });

  calc = function(datas) {
    return function(next) {
      var TIME_DATA, aliases, currentTimes, delayTimes, delayTimesAliased, distances, distancesAliased, frame, now, pulseTimes, pulseTimesAliased, recStartTimes, relDelayTimes, relDelayTimesAliased, results, sampleRates;
      if (datas.length === 0) {
        return next();
      }
      now = Date.now();
      frame = _craetePictureFrame("calc", document.body);
      aliases = datas.reduce((function(o, arg) {
        var alias, id;
        id = arg.id, alias = arg.alias;
        o[id] = alias;
        return o;
      }), {});
      results = datas.map(function(arg) {
        var DSSS_SPEC, _frame, _results, alias, carrier_freq, id, length, matchedA, matchedB, mseqA, mseqB, recF32arr, sampleRate, seedA, seedB, startStops;
        id = arg.id, alias = arg.alias, startStops = arg.startStops, recF32arr = arg.recF32arr, DSSS_SPEC = arg.DSSS_SPEC, sampleRate = arg.sampleRate;
        length = DSSS_SPEC.length, seedA = DSSS_SPEC.seedA, seedB = DSSS_SPEC.seedB, carrier_freq = DSSS_SPEC.carrier_freq;
        _frame = _craetePictureFrame(alias + "@" + id);
        frame.add(_frame.element);
        mseqA = Signal.mseqGen(length, seedA);
        mseqB = Signal.mseqGen(length, seedB);
        matchedA = Signal.BPSK(mseqA, carrier_freq, sampleRate, 0);
        matchedB = Signal.BPSK(mseqB, carrier_freq, sampleRate, 0);
        recF32arr = new Float32Array(recF32arr);
        console.log(recF32arr.length, alias);
        _results = startStops.map(function(arg1) {
          var _, __frame, _id, correl, correlA, correlB, i, idx, idxA, idxB, logs, marker, max_offset, pulseTime, range, rawdata, ref, ref1, ref2, ref3, relA, relB, scoreA, scoreB, section, slidewidth, startPtr, stdscoreA, stdscoreB, stopPtr, val, windowsize, zoom, zoomA, zoomB;
          _id = arg1.id, startPtr = arg1.startPtr, stopPtr = arg1.stopPtr;
          console.log(_id, startPtr, stopPtr);
          __frame = _craetePictureFrame(aliases[id] + "<->" + aliases[_id]);
          _frame.add(__frame.element);
          rawdata = section = recF32arr.subarray(startPtr, stopPtr);
          correlA = Signal.fft_smart_overwrap_correlation(rawdata, matchedA);
          correlB = Signal.fft_smart_overwrap_correlation(rawdata, matchedB);
          __frame.view(section, "section");
          __frame.view(correlA, "correlA");
          __frame.view(correlB, "correlB");
          ref = Signal.Statictics.findMax(correlA), _ = ref[0], idxA = ref[1];
          ref1 = Signal.Statictics.findMax(correlB), _ = ref1[0], idxB = ref1[1];
          relB = idxA + matchedA.length * 2;
          relA = idxB - matchedA.length * 2;
          stdscoreA = (function() {
            var ave, vari;
            ave = Signal.Statictics.average(correlA);
            vari = Signal.Statictics.variance(correlA);
            return function(x) {
              return 10 * (x - ave) / vari + 50;
            };
          })();
          stdscoreB = (function() {
            var ave, vari;
            ave = Signal.Statictics.average(correlB);
            vari = Signal.Statictics.variance(correlB);
            return function(x) {
              return 10 * (x - ave) / vari + 50;
            };
          })();
          scoreB = stdscoreB(correlB[idxB]) + stdscoreA(correlA[relA]);
          scoreA = stdscoreA(correlA[idxA]) + stdscoreB(correlB[relB]);
          range = (MULTIPASS_DISTANCE / SOUND_OF_SPEED * sampleRate) | 0;
          if (relA > 0 && scoreB > scoreA) {
            idxA = relA;
          } else {
            idxB = relB;
          }
          marker = new Uint8Array(correlA.length);
          marker[idxA - range] = 255;
          marker[idxA] = 255;
          marker[idxA + range] = 255;
          marker[idxB - range] = 255;
          marker[idxB] = 255;
          marker[idxB + range] = 255;
          __frame.view(marker, "marker");
          zoomA = correlA.subarray(idxA - range, idxA + range);
          zoomB = correlB.subarray(idxB - range, idxB + range);
          __frame.view(zoomA, "zoomA");
          __frame.view(zoomB, "zoomB");
          correl = Signal.fft_smart_overwrap_correlation(zoomA, zoomB);
          __frame.view(correl, "correl");
          ref2 = Signal.Statictics.findMax(correl), _ = ref2[0], idx = ref2[1];
          idxB += idx;
          zoomB = correlB.subarray(idxB - range, idxB + range);
          __frame.view(zoomB, "zoomB(adjasted(+" + idx + "))");
          idxB -= idx;
          zoomB = correlB.subarray(idxB - range, idxB + range);
          __frame.view(zoomB, "zoomB(adjasted(-" + idx + "))");
          zoom = zoomA.map(function(_, i) {
            return zoomA[i] * zoomB[i];
          });
          logs = new Float32Array(zoomA.length);
          windowsize = 128;
          slidewidth = 1;
          i = 0;
          while (zoomA.length > i + windowsize) {
            val = zoom.subarray(i, i + windowsize).reduce((function(sum, v, i) {
              return sum + v;
            }), 0);
            logs[i] = val;
            i += slidewidth;
          }
          __frame.view(logs, "logs");
          ref3 = Signal.Statictics.findMax(logs), _ = ref3[0], idx = ref3[1];
          marker = new Uint8Array(logs.length);
          marker[idx] = 255;
          __frame.view(marker, "marker");
          max_offset = idx + (idxA - range);
          pulseTime = (startPtr + max_offset) / sampleRate;
          return {
            id: _id,
            max_offset: max_offset,
            pulseTime: pulseTime
          };
        });
        return {
          id: id,
          alias: alias,
          results: _results
        };
      });
      sampleRates = datas.reduce((function(o, arg) {
        var id, sampleRate;
        id = arg.id, sampleRate = arg.sampleRate;
        o[id] = sampleRate;
        return o;
      }), {});
      recStartTimes = datas.reduce((function(o, arg) {
        var id, recStartTime;
        id = arg.id, recStartTime = arg.recStartTime;
        o[id] = recStartTime;
        return o;
      }), {});
      currentTimes = datas.reduce((function(o, arg) {
        var currentTime, id;
        id = arg.id, currentTime = arg.currentTime;
        o[id] = currentTime;
        return o;
      }), {});
      pulseTimes = {};
      relDelayTimes = {};
      delayTimes = {};
      distances = {};
      relDelayTimesAliased = {};
      distancesAliased = {};
      delayTimesAliased = {};
      pulseTimesAliased = {};
      results.forEach(function(arg) {
        var alias, id, results;
        id = arg.id, alias = arg.alias, results = arg.results;
        return results.forEach(function(arg1) {
          var _id, max_offset, pulseTime;
          _id = arg1.id, max_offset = arg1.max_offset, pulseTime = arg1.pulseTime;
          pulseTimes[id] = pulseTimes[id] || {};
          pulseTimes[id][_id] = pulseTime;
          pulseTimesAliased[aliases[id]] = pulseTimesAliased[aliases[id]] || {};
          return pulseTimesAliased[aliases[id]][aliases[_id]] = pulseTimes[id][_id];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          relDelayTimes[id1] = relDelayTimes[id1] || {};
          relDelayTimes[id1][id2] = pulseTimes[id1][id2] - pulseTimes[id1][id1];
          relDelayTimesAliased[aliases[id1]] = relDelayTimesAliased[aliases[id1]] || {};
          return relDelayTimesAliased[aliases[id1]][aliases[id2]] = relDelayTimes[id1][id2];
        });
      });
      Object.keys(pulseTimes).forEach(function(id1) {
        return Object.keys(pulseTimes).forEach(function(id2) {
          delayTimes[id1] = delayTimes[id1] || {};
          delayTimes[id1][id2] = Math.abs(Math.abs(relDelayTimes[id1][id2]) - Math.abs(relDelayTimes[id2][id1]));
          delayTimesAliased[aliases[id1]] = delayTimesAliased[aliases[id1]] || {};
          delayTimesAliased[aliases[id1]][aliases[id2]] = delayTimes[id1][id2];
          distances[id1] = distances[id1] || {};
          distances[id1][id2] = Math.abs(delayTimes[id1][id2]) / 2 * SOUND_OF_SPEED;
          distancesAliased[aliases[id1]] = distancesAliased[aliases[id1]] || {};
          return distancesAliased[aliases[id1]][aliases[id2]] = distances[id1][id2];
        });
      });
      console.group("table");
      console.info("recStartTimes", recStartTimes);
      console.info("pulseTimesAliased");
      console.table(pulseTimesAliased);
      console.info("relDelayTimesAliased");
      console.table(relDelayTimesAliased);
      console.info("delayTimesAliased");
      console.table(delayTimesAliased);
      console.info("distancesAliased");
      console.table(distancesAliased);
      console.groupEnd();
      document.body.style.backgroundColor = "lime";
      TIME_DATA = {
        pulseTimes: pulseTimes,
        delayTimes: delayTimes,
        aliases: aliases,
        recStartTimes: recStartTimes,
        now: now,
        currentTimes: currentTimes,
        id: results[0].id,
        distances: distances
      };
      return next(TIME_DATA);
    };
  };

  VIEW_SIZE = Math.pow(2, 12);

  _craetePictureFrame = function(description, target) {
    var fieldset, legend, style;
    fieldset = document.createElement('fieldset');
    style = document.createElement('style');
    style.appendChild(document.createTextNode("canvas,img{border:1px solid black;}"));
    style.setAttribute("scoped", "scoped");
    fieldset.appendChild(style);
    legend = document.createElement('legend');
    legend.appendChild(document.createTextNode(description));
    fieldset.appendChild(legend);
    fieldset.style.display = 'inline-block';
    fieldset.style.backgroundColor = "white";
    if (target != null) {
      target.appendChild(fieldset);
    }
    return {
      element: fieldset,
      add: function(element) {
        var p, txtNode;
        if (typeof element === "string") {
          txtNode = document.createTextNode(element);
          p = document.createElement("p");
          p.appendChild(txtNode);
          return fieldset.appendChild(p);
        } else {
          return fieldset.appendChild(element);
        }
      },
      view: function(arr, title) {
        var __frame, render, width;
        if (title == null) {
          title = "";
        }
        __frame = _craetePictureFrame(title + ("(" + arr.length + ")"));
        width = VIEW_SIZE < arr.length ? VIEW_SIZE : arr.length;
        render = new SignalViewer(width, 64);
        render.draw(arr);
        __frame.add(render.cnv);
        this.add(__frame.element);
        return this.add(document.createElement("br"));
      },
      text: function(title) {
        this.add(document.createTextNode(title));
        return this.add(document.createElement("br"));
      }
    };
  };

}).call(this);
