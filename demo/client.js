// Generated by CoffeeScript 1.10.0
var _beep, _flipProc, _merge, _preparePulse, _prepareRec, abuf, actx, isRecording, main, osc, processor, pulse, pulseStartTime, pulseStopTime, recbuf, setup;

setup = function() {
  var changeColor, socket;
  window.navigator["getUserMedia"] = window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia || window.navigator.getUserMedia;
  changeColor = function() {
    return document.body.style.backgroundColor = location.hash.slice(1);
  };
  window.addEventListener("DOMContentLoaded", changeColor);
  window.addEventListener("hashchange", changeColor);
  window["socket"] = socket = io(location.hostname + ":" + location.port);
  socket.on("connect", console.info.bind(console, "connect"));
  socket.on("reconnect", console.info.bind(console, "reconnect"));
  socket.on("reconnect_attempt", console.info.bind(console, "reconnect_attempt"));
  socket.on("reconnecting", console.info.bind(console, "reconnecting"));
  socket.on("reconnect_error", console.info.bind(console, "reconnect_error"));
  socket.on("reconnect_failed", console.info.bind(console, "reconnect_failed"));
  socket.on("disconnect", console.info.bind(console, "disconnect"));
  socket.on("error", console.info.bind(console, "error"));
  socket.on("echo", console.info.bind(console, "echo"));
  socket.on("connect", function() {
    return socket.emit("echo", "hello");
  });
  return window.onerror = function(err) {
    var pre, textnode;
    console.error(err);
    document.body.style.backgroundColor = "gray";
    pre = document.createElement("pre");
    textnode = document.createTextNode(err.stack || err);
    pre.appendChild(textnode);
    return document.body.appendChild(pre);
  };
};

actx = new AudioContext();

osc = new OSC(actx);

processor = actx.createScriptProcessor(Math.pow(2, 14), 1, 1);

recbuf = new RecordBuffer(actx.sampleRate, processor.bufferSize, processor.channelCount);

isRecording = false;

pulseStartTime = {};

pulseStopTime = {};

pulse = null;

abuf = null;

main = function() {
  var beepPulse, ready, sendRec, startPulse, startRec, stopPulse, stopRec;
  socket.on("ready", function() {
    return ready(function() {
      return socket.emit("ready");
    });
  });
  socket.on("startRec", function() {
    return startRec(function() {
      return socket.emit("startRec");
    });
  });
  socket.on("startPulse", function(a) {
    return startPulse(a)(function() {
      return socket.emit("startPulse");
    });
  });
  socket.on("beepPulse", function() {
    return beepPulse(function() {
      return socket.emit("beepPulse");
    });
  });
  socket.on("stopPulse", function(a) {
    return stopPulse(a)(function() {
      return socket.emit("stopPulse");
    });
  });
  socket.on("stopRec", function() {
    return stopRec(function() {
      return socket.emit("stopRec");
    });
  });
  socket.on("sendRec", function() {
    return sendRec(function(a) {
      return socket.emit("sendRec", a);
    });
  });
  ready = function(next) {
    return _preparePulse(function() {
      return _prepareRec(function() {
        return next();
      });
    });
  };
  startRec = _flipProc(function() {
    return isRecording = true;
  });
  startPulse = function(id) {
    return _flipProc(function() {
      return pulseStartTime[id] = actx.currentTime;
    });
  };
  beepPulse = _beep;
  stopPulse = function(id) {
    return _flipProc(function() {
      return pulseStopTime[id] = actx.currentTime;
    });
  };
  stopRec = _flipProc(function() {
    return isRecording = false;
  });
  return sendRec = function(next) {
    var f32arr, o;
    f32arr = recbuf.merge();
    console.log(f32arr);
    o = {
      id: socket.id,
      alias: location.hash.slice(1),
      pulseStartTime: pulseStartTime,
      pulseStopTime: pulseStopTime,
      sampleTimes: recbuf.sampleTimes,
      sampleRate: actx.sampleRate,
      bufferSize: processor.bufferSize,
      channelCount: processor.channelCount,
      recF32arr: f32arr.buffer,
      recF32arrLen: f32arr.length,
      pulseF32arr: pulse.buffer,
      pulseF32arrLen: pulse.length
    };
    recbuf.clear();
    return next(o);
  };
};

_preparePulse = function(next) {
  return osc.createBarkerCodedChirp(13, 8).then(function(_pulse) {
    pulse = _pulse;
    abuf = osc.createAudioBufferFromArrayBuffer(pulse, actx.sampleRate);
    return next();
  });
};

_prepareRec = function(next) {
  var left, right;
  left = function(err) {
    throw err;
  };
  right = function(stream) {
    var source;
    source = actx.createMediaStreamSource(stream);
    source.connect(processor);
    processor.connect(actx.destination);
    processor.addEventListener("audioprocess", function(ev) {
      if (isRecording) {
        return recbuf.add([new Float32Array(ev.inputBuffer.getChannelData(0))], actx.currentTime);
      }
    });
    return next();
  };
  return navigator.getUserMedia({
    video: false,
    audio: true
  }, right, left);
};

_beep = function(next) {
  var anode;
  anode = osc.createAudioNodeFromAudioBuffer(abuf);
  anode.connect(actx.destination);
  anode.start(actx.currentTime);
  return setTimeout(next, pulse.length / actx.sampleRate * 1000);
};

_flipProc = function(next) {
  return function(proc) {
    proc();
    return next();
  };
};

_merge = function(base, overwrite) {
  Object.keys(overwrite).forEach(function(key) {
    return base[key] = overwrite[key];
  });
  return base;
};

setup();

main();
